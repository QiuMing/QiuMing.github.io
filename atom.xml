<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xqMing</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-10T14:23:24.359Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xqMing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次大厂面</title>
    <link href="http://yoursite.com/2018/06/10/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%A7%E5%8E%82%E9%9D%A2/"/>
    <id>http://yoursite.com/2018/06/10/记一次大厂面/</id>
    <published>2018-06-10T14:10:38.000Z</published>
    <updated>2018-06-10T14:23:24.359Z</updated>
    
    <content type="html"><![CDATA[<p>阿里是我最向往的公司之一，最近在拉勾上投简历，被阿里的技术leader邀请投递简历，并且进行了电话面和视屏面。两轮面试过程中，答出了不少，也有不少被问懵了，学习到了不少。再此对一些问题做一些记录。</p>
<a id="more"></a>
<h3 id="ConcurrentHashMap-底层实现，常用方法是怎么保证线程安全的"><a href="#ConcurrentHashMap-底层实现，常用方法是怎么保证线程安全的" class="headerlink" title="ConcurrentHashMap 底层实现，常用方法是怎么保证线程安全的"></a>ConcurrentHashMap 底层实现，常用方法是怎么保证线程安全的</h3><p>底层实现：</p>
<ul>
<li>jdk7：ReentrantLock+Segment+HashEntry (使用分段锁技术，细化锁的粒度)</li>
<li>jdk8：synchronized+CAS+HashEntry+红黑树 </li>
</ul>
<p>下面谈谈，JDK 7 中，各个方法是怎么保证线程安全的：</p>
<ul>
<li>get()：性能高效，get 的过程不加锁，因为get方法将要使用的共享变量，都使用了 volatile 关键字，保证不会读到过期的值。</li>
<li>put()：涉及对共享变量的写操作，会加锁，代码里面明确可以看到 <strong>lock();</strong> 和 <strong>unlock</strong>。<strong>Segment</strong> 继承了 <strong>ReentrantLock </strong></li>
<li>size()：有两种方案，A方案先无锁获取两次，比较值，相等就返回，不相等则采用B方案，通过对所有 <strong>Segment</strong>加锁来统计。</li>
</ul>
<p>推荐深入阅读：<a href="https://www.cnblogs.com/study-everyday/p/6430462.html#autoid-2-2-5" target="_blank" rel="external">ConcurrentHashMap 原理分析</a></p>
<h3 id="Zookeeper-使用的协议"><a href="#Zookeeper-使用的协议" class="headerlink" title="Zookeeper 使用的协议"></a>Zookeeper 使用的协议</h3><p>Zookeeper 使用了一种称为Zookeeper Atomic Broadcat(ZAB，ZooKeeper原子消息广播协议)的协议，作为其数据一致性的核心算法，是Paxos算法的变种，相比Paxos，Zab最大的特点是保证强一致性。</p>
<p>推荐深入阅读书籍：《从Paxos到ZooKeeper，分布式一致性原理与实践》</p>
<h3 id="Mysql-两种引擎MyISAM和InnoDB的区别"><a href="#Mysql-两种引擎MyISAM和InnoDB的区别" class="headerlink" title="Mysql 两种引擎MyISAM和InnoDB的区别"></a>Mysql 两种引擎MyISAM和InnoDB的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody>
<tr>
<td>事务处理</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>外键</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>表总行数，不加where</td>
<td>没有保存</td>
<td>有保存</td>
</tr>
<tr>
<td>全文索引</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>锁支持情况</td>
<td>支持到行级锁</td>
<td>只支持表级锁</td>
</tr>
</tbody>
</table>
<p>推荐深入阅读：<a href="https://blog.csdn.net/lc0817/article/details/52757194" target="_blank" rel="external">MySQL存储引擎中的MyISAM和InnoDB区别详解</a></p>
<h3 id="Spring-事物7种传播特性，5种隔离级别"><a href="#Spring-事物7种传播特性，5种隔离级别" class="headerlink" title="Spring 事物7种传播特性，5种隔离级别"></a>Spring 事物7种传播特性，5种隔离级别</h3><p>7种传播特性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1、PROPAGATION_REQUIRED 支持当前事务，如果不存在 就新建一个(默认) </div><div class="line">2、PROPAGATION_SUPPORTS 支持当前事务，如果不存在，就不使用事务 </div><div class="line">3、PROPAGATION_MANDATORY 支持当前事务，如果不存在，抛出异常 </div><div class="line">4、PROPAGATION_REQUIRES_NEW 如果有事务存在，挂起当前事务，创建一个新的事务 </div><div class="line">5、PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务 </div><div class="line">6、PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常 </div><div class="line">7、PROPAGATION_NESTED 如果当前事务存在，则嵌套事务执行</div></pre></td></tr></table></figure></p>
<p>5种隔离级别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1、Serializable ：最严格的级别，事务串行执行，资源消耗最大；</div><div class="line">2、REPEATABLE READ ：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据。避免了&quot;脏读取&quot;和&quot;不可重复读取&quot;的情况，但是带来了更多的性能损失</div><div class="line">3、READ COMMITTED :大多数主流数据库的默认事务等级，保证了一个事务不会读到另一个并行事务已修改但未提交的数据，避免了&quot;脏读取&quot;。该级别适用于大多数系统。</div><div class="line">4、Read Uncommitted ：保证了读取过程中不会读取到非法数据。</div></pre></td></tr></table></figure></p>
<h3 id="并行框架-Fork-Join-使用"><a href="#并行框架-Fork-Join-使用" class="headerlink" title="并行框架 Fork/Join 使用"></a>并行框架 Fork/Join 使用</h3><p>Fork/Join 框架是 Java7 提供的一个用于并行执行任务的框架，是一个把任务分割成若干小任务，并最终汇总小任务结果后得到大任务结果的框架。</p>
<p>使用的算法：<strong>窃取算法</strong>，即<strong>把某个线程从其它队列里窃取来执行</strong>。这样可以充分利用线程进行并行计算，<strong>减少线程竞争时间</strong>。</p>
<p>涉及到的核心类：<br><strong>RecursiveTask</strong>：ForkJoinTask 子类，用于有返回结果的任务。<br><strong>RecursiveAction</strong>：ForkJoinTask 子类，用于有返回结果的任务。<br><strong>ForkJoinPool</strong>：所有的 ForkJoinTask 都需要通过ForkJoinPool来执行。</p>
<h3 id="Happern-before-六原则"><a href="#Happern-before-六原则" class="headerlink" title="Happern before 六原则"></a>Happern before 六原则</h3><ul>
<li><strong>程序顺序规则：</strong> 一个线程中的每个操作，happens-before于随后该线程中的任意后续操作</li>
<li><strong>监视器锁规则：</strong> 对一个锁的解锁，happens-before于随后对这个锁的获取</li>
<li><strong>volatile变量规则：</strong> 对一个volatile域的写，happens-before于对这个变量的读</li>
<li><strong>传递性：</strong> 如果A happens-before B，B happens-before C，那么A happens-before C</li>
<li><strong>start规则：</strong> 如果线程A执行线程B的start方法，那么线程A的ThreadB.start()happens-before于线程B的任意操作</li>
<li><strong>join规则：</strong> Z如果线程A执行线程B的join方法，那么线程B的任意操作happens-before于线程A从TreadB.join()方法成功返回。</li>
</ul>
<h3 id="四种GC-Root"><a href="#四种GC-Root" class="headerlink" title="四种GC Root"></a>四种GC Root</h3><p>主要分布在栈和方法区这两个地方</p>
<ul>
<li>虚拟机栈中的引用对象</li>
<li>本地方法栈中JNI引用对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用对象</li>
</ul>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>一个类的加载器，收到类加载的请求时，先不会自己尝试加载这个类，而是委托给父类加载器，每层的类加载器都如此，只有当父类无法加载该类，才让子类自己加载。</p>
<p>优点：类与类加载器，一起具备了一种<strong>带有优先级的层次关系</strong>，方便了维护管理。<br>破坏双亲委派的例子：<strong>JNDI 服务调用</strong>；<strong>OSGI</strong>；<strong>代码热部署</strong>。</p>
<h3 id="线程池连环炮"><a href="#线程池连环炮" class="headerlink" title="线程池连环炮"></a>线程池连环炮</h3><p>先问线程池 ThreadPoolExecutor 的参数，由此引发线程池大小，任务队列，饱和策略等系列问题。</p>
<h4 id="如何确定线程池的大小？"><a href="#如何确定线程池的大小？" class="headerlink" title="如何确定线程池的大小？"></a>如何确定线程池的大小？</h4><p>一种简单的计算方式，假设CPU 为N：</p>
<ul>
<li>如果是CPU密集型，建议为N + 1</li>
<li>如果是计算密集型，建议为2N + 1</li>
</ul>
<p>推荐深入阅读：<a href="http://ifeve.com/how-to-calculate-threadpool-size/" target="_blank" rel="external">如何合理地估算线程池大小？</a></p>
<h4 id="可以选择哪几个任务队列？"><a href="#可以选择哪几个任务队列？" class="headerlink" title="可以选择哪几个任务队列？"></a>可以选择哪几个任务队列？</h4><ul>
<li>ArrayBlockingQueue：基于数据的有界阻塞队列，按FIFO 原则排序。</li>
<li>LinkedBlockingQueue：基于链表的阻塞队列，按FIFO 原则排序，<strong>吞吐量要高于ArrayBlockingQueue</strong>。</li>
<li>SynchronousQueue：不存储元素的阻塞队列。静态工厂方法 *Executors.</li>
<li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li>
</ul>
<h4 id="了解饱和策略？什么时候促发该策略，有哪几种？"><a href="#了解饱和策略？什么时候促发该策略，有哪几种？" class="headerlink" title="了解饱和策略？什么时候促发该策略，有哪几种？"></a>了解饱和策略？什么时候促发该策略，有哪几种？</h4><p><strong>促发条件：</strong>当核心线程池满（corePoolSize），任务会放到队列里。当队列也满了，会判断线程数是否小于最大的线程池配置数（maximumPoolSize）。如果小于，则继续新建线程，如果已经达到最大值，促发饱和策略。</p>
<p><strong>策略类型：</strong></p>
<ul>
<li>AborPolicy：默认策略，抛出异常</li>
<li>CallerRUnsPolicy：用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里的最近一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢失掉。</li>
<li>自定义的拒绝策略，比如记录日志，或者持久化不能处理的任务</li>
</ul>
<h3 id="Dubbo-超时机制"><a href="#Dubbo-超时机制" class="headerlink" title="Dubbo 超时机制"></a>Dubbo 超时机制</h3><p>Dubbo 底层使用了Netty 通信。消费端发起远程请求后，线程不会阻塞等待服务端的返回，而是马上得到一个ResponseFuture，消费端通过不断的轮询机制判断结果是否有返回。因为是通过轮询，轮询有个需要特别注要的就是<strong>避免死循环</strong>，所以为了解决这个问题就<strong>引入了超时机制</strong>，只在一定时间范围内做轮询，如果超时时间就返回超时异常。更多详情可以看 <strong>DefaultFuture</strong> 类的</p>
<p>推荐深入阅读：<br><a href="https://www.cnblogs.com/ASPNET2008/p/7292472.html" target="_blank" rel="external">dubbo源码分析（二）：超时原理以及应用场景</a><br><a href="https://blog.csdn.net/paul_wei2008/article/details/19355681" target="_blank" rel="external">Dubbo基本原理机制</a></p>
<h3 id="Spring的BeanFactoryPostProcessor和BeanPostProcessor-区别"><a href="#Spring的BeanFactoryPostProcessor和BeanPostProcessor-区别" class="headerlink" title="Spring的BeanFactoryPostProcessor和BeanPostProcessor 区别"></a>Spring的BeanFactoryPostProcessor和BeanPostProcessor 区别</h3><p><strong>PostProcessor</strong>：后处理器；<br><strong>BeanPostProcessor</strong>：Bean的后置处理器（处理的对象是Bean）；该接口有两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//bean对象实例化前执行的操作</div><div class="line">Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;</div><div class="line">//bean对象实例化执行的操作</div><div class="line">Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;</div></pre></td></tr></table></figure></p>
<p>这个接口的处理，是<strong>发生在Spring容器的实例化和依赖注入完成之后</strong>。<br>默认是会对整个Spring容器中所有的bean进行处理，可以通过方法中的参数，对指定的bena进行处理。</p>
<p><strong>BeanFactoryPostProcessor</strong>：BeanFactory的后置处理器（处理的对象是BeanFactory）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException;</div></pre></td></tr></table></figure></p>
<p>该接口的调用时间是，Spring 容器<strong>刚完成BeanDefinition的解析，尚未实例化bean</strong>。可以<strong>用于修改bean的定义属性</strong>。</p>
<p>相同点：二者都是spring初始化bean时对外暴露的扩展点接口。<br>不同点：</p>
<ul>
<li>二者的处理时间不同.</li>
<li>方法不同，作用不同。</li>
</ul>
<p>推荐深入阅读：<a href="https://blog.csdn.net/caihaijiang/article/details/35552859" target="_blank" rel="external">Spring的BeanFactoryPostProcessor和BeanPostProcessor</a></p>
<p>TODO<br>未完待续</p>
<p>TODO<br>未完待续</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阿里是我最向往的公司之一，最近在拉勾上投简历，被阿里的技术leader邀请投递简历，并且进行了电话面和视屏面。两轮面试过程中，答出了不少，也有不少被问懵了，学习到了不少。再此对一些问题做一些记录。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>在 Spring 中实现组合请求接口</title>
    <link href="http://yoursite.com/2018/05/29/%E5%9C%A8Spring%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/05/29/在Spring中实现组合请求接口/</id>
    <published>2018-05-29T14:03:57.000Z</published>
    <updated>2018-06-04T15:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>App 在启动的时候，会调用服务端多个接口，随着业务迭代开发，请求接口会越来越多，致使 App 在启动的时候会有多次 IO 请求，启动缓慢。</li>
<li>为解决此问题，App 端同学会要求服务端同学，在一个接口内，返回多种业务数据，或者要求在一个接口，组合响应多个接口数据。在此背景下，组合请求接口因需而生。</li>
</ul>
<a id="more"></a>
<p>将接口合并请求，笔者了解到，有如下解决方案：</p>
<ul>
<li>使用 API 网关。</li>
<li>使用 <a href="https://github.com/facebook/graphql" target="_blank" rel="external">GraphQL</a>。</li>
</ul>
<p>GraphQL 是Facebook 推出的一种用于应用层的 API 查询语言，它有一套完善的规范，不同语言都有提供对其的支持。不过引入 GraphQL ，需要引入额外的依赖，并且开发团队都要了解 GraphQL 的使用。</p>
<p>上面介绍的2种方案，都需要引入新的东西，有一定的成本。下面笔者介绍的方案，通过利用 Java 中强大的 <strong>反射机制</strong> ，可以在现有的 Spring 技术栈中，以较为简单的方式，实现组合请求接口，下面的文字里，笔者将介绍它的使用方式，实现原理。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>在对应的处理方法上加上 <strong>@EnableCombineRequest</strong> 注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@EnableCombineRequest</div><div class="line">@GetMapping(path = &quot;/liang&quot;)</div><div class="line">public UserDto getLiang(@RequestParam(name=&quot;userName&quot;,defaultValue = &quot;明&quot;)String  name,Integer id) &#123;</div><div class="line">    log.info(&quot;name:&#123;&#125;,age:&#123;&#125;&quot;,name,id);</div><div class="line">    return new UserDto(id,name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请求的 request<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&#123;<span class="attr">"method"</span>:<span class="string">"GET"</span>,<span class="attr">"requestId"</span>:<span class="string">"222"</span>,<span class="attr">"url"</span>:<span class="string">"/fang"</span>&#125;,&#123;<span class="attr">"method"</span>:<span class="string">"GET"</span>,<span class="attr">"requestId"</span>:<span class="string">"111"</span>,<span class="attr">"url"</span>:<span class="string">"/ming"</span>&#125;]</div></pre></td></tr></table></figure></p>
<p>响应的 response</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&#123;<span class="attr">"requestId"</span>:<span class="string">"222"</span>,<span class="attr">"url"</span>:<span class="string">"/fang"</span>,<span class="attr">"httpStatus"</span>:<span class="number">200</span>,<span class="attr">"entity"</span>:&#123;<span class="attr">"id"</span>:<span class="number">1</span>,<span class="attr">"name"</span>:<span class="string">"芳"</span>&#125;&#125;,&#123;<span class="attr">"requestId"</span>:<span class="string">"111"</span>,<span class="attr">"url"</span>:<span class="string">"/ming"</span>,<span class="attr">"httpStatus"</span>:<span class="number">200</span>,<span class="attr">"entity"</span>:&#123;<span class="attr">"id"</span>:<span class="number">2</span>,<span class="attr">"name"</span>:<span class="string">"明"</span>&#125;&#125;]</div></pre></td></tr></table></figure>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>实现组合请求，需要客户端同学自己组合请求的 <strong>url</strong> 和 <strong>参数</strong>， 服务端则利用 <strong>ReflectionUtils.invokeMethod(method, object, args);</strong> 方法，来获取单个请求的响应结果，组合响应请求后，统一返回。这其中，要重点了解这里用到的这个反射方法：</p>
<ul>
<li><strong>ReflectionUtils</strong> 是 Spring 中提供的工具类；</li>
<li><strong>method</strong> 是单个请求的实际处理方法；</li>
<li><strong>object</strong> 参数是处理方法所在的类；</li>
<li><strong>args</strong> 是方法所需要的参数值；</li>
</ul>
<p><strong>ReflectionUtils</strong> 方法拿来即用即可，另外方法需要的参数，是需要深入了解 Spring 机制后，根据客户端传入参数获取。</p>
<h3 id="获取请求处理的方法"><a href="#获取请求处理的方法" class="headerlink" title="获取请求处理的方法"></a>获取请求处理的方法</h3><p>在 Spring MVC 中，一种 url 请求，都有一个 <strong>HandlerMethod</strong> 来处理，通过 <strong>URL+HTTP mthod</strong>，可以获取到一个 <strong>HandlerMethod</strong> 。通过注入 <strong>requestMappingHandlerMapping</strong>，可以获取到 <strong>Map<requestmappinginfo, handlermethod=""></requestmappinginfo,></strong>，<strong>RequestMappingInfo</strong> 中包含了请求 url 和请求方法的信息，通过遍历，可以获取到 <strong>HandlerMethod</strong> 实例。</p>
<h3 id="获取请求方法所在类"><a href="#获取请求方法所在类" class="headerlink" title="获取请求方法所在类"></a>获取请求方法所在类</h3><p>通过 <strong>ApplicationContext</strong> 的 <strong>getBean</strong> 方法获取，其中 Bean 的名字，可以从 <strong>HandlerMethod</strong> 中获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object object = context.getBean(requestItemHandlerMethod.getBean().toString());</div></pre></td></tr></table></figure>
<h3 id="获取请求方法需要的-参数值"><a href="#获取请求方法需要的-参数值" class="headerlink" title="获取请求方法需要的 参数值"></a>获取请求方法需要的 <strong>参数值</strong></h3><p><strong>参数值</strong> 的来源有三种：</p>
<blockquote>
<p>请求的 <strong>url</strong> 上<br>源于客户端传入的 param<br>注解参数的默认值</p>
</blockquote>
<p>使用 <strong>DefaultParameterNameDiscoverer</strong> 类，反射获取方法的参数; 通过 <strong>MethodParameter</strong> 类，获取参数中使用到的注解，并进行处理。<br>其中对注解参数的处理，参考了 <strong>org.springframework.web.bind.annotation.support.HandlerMethodInvoker#resolveHandlerArguments</strong> ，<strong>HandlerMethodInvoker</strong> 该类在 <strong>spring-web 5.0</strong> 的版本已经移除。</p>
<h2 id="安全性考虑"><a href="#安全性考虑" class="headerlink" title="安全性考虑"></a>安全性考虑</h2><p>实际应用场景下，仅有部分接口需要合并请求，因此，如果一个接口要支持组合请求，需要在接口上加上 <strong>EnableCombineRequest</strong> 注解，以避免组合请求接口滥用。</p>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><ul>
<li>如果项目中有用到拦截器，并且组合接口中的部分请求，在该拦截链中有做特殊处理，比如权限校验，设置请求上下文信息等，需要对组合接口进行特殊的处理，或者将组合接口，也放到该拦截链中。</li>
<li>目前仅实现了 <strong>@RequestParam</strong> 和 <strong>@PathVariable</strong> 注解的支持，对常见的 <strong>Get</strong> 请求支持比较好，尚未对 <strong>@Valid</strong> 等注解做处理。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;App 在启动的时候，会调用服务端多个接口，随着业务迭代开发，请求接口会越来越多，致使 App 在启动的时候会有多次 IO 请求，启动缓慢。&lt;/li&gt;
&lt;li&gt;为解决此问题，App 端同学会要求服务端同学，在一个接口内，返回多种业务数据，或者要求在一个接口，组合响应多个接口数据。在此背景下，组合请求接口因需而生。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 在贝聊的应用</title>
    <link href="http://yoursite.com/2018/05/29/Spring-Boot-%E5%9C%A8%E8%B4%9D%E8%81%8A%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/05/29/Spring-Boot-在贝聊的应用/</id>
    <published>2018-05-29T13:28:32.000Z</published>
    <updated>2018-05-29T13:48:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Spring Boot 生态社区的日益强大，贝聊服务端团队在开发部分新系统时，也逐步采用了 Spring Boot 框架，并且积累了一定的经验，在此和大家做个分享。</p>
<a id="more"></a>
<h2 id="Spring-Boot-的优点"><a href="#Spring-Boot-的优点" class="headerlink" title="Spring Boot 的优点"></a>Spring Boot 的优点</h2><p>项目采用 Spring Boot ，和直接使用 Spring MVC ，有什么优点了？这里我们分析了下，大概有以下几点：</p>
<ul>
<li>使用 Java Config 的配置方式替代 xml文件 配置，实现配置类复用。避免每次构建新的 Spring MVC 建项目，都得往旧的项目中拷贝 xml 配置文件。</li>
<li>社区提供的丰富的 Starter pom 依赖包，极大方便了我们整合第三方框架。</li>
<li>提供嵌入式 Servlet 容器，支持 jar 和 war 部署，给运维和开发都带来了极大的便利。</li>
<li>自动管理依赖，勉去版本冲突烦恼。</li>
<li>提供了基本的应用监控的功能。</li>
</ul>
<p>总结来说，相比于直接使用 Spring MVC 构建项目，Spring Boot 使我们在开发、配置、监控、部署的过程中，都变得更加简单。</p>
<h2 id="Spring-Boot-在贝聊的应用情况"><a href="#Spring-Boot-在贝聊的应用情况" class="headerlink" title="Spring Boot 在贝聊的应用情况"></a>Spring Boot 在贝聊的应用情况</h2><p>在讲Spring Boot 之前，有必要讲下我们贝聊服务端现在有用到的技术栈：</p>
<ul>
<li>基础框架 Spring MVC；</li>
<li>服务治理方面，使用了 Dubbo；</li>
<li>数据库层面，使用了 Mybatis，Druid，并配置了多数据源；</li>
<li>权限控制用到 Shiro；</li>
<li>分布式配置，使用了 Disconf；</li>
<li>分布式定时任务，使用 Elastic-Job；</li>
<li>全链路监控方面使用了 Cat；</li>
<li>部署方面，我们用自己的发布系统；</li>
</ul>
<p>引入Spring Boot ，则必须要支持我们现有的技术栈，并且要能够让新同事能够很快熟悉。依托于Spring Boot 约定优于配置的理念，及官方和社区提供的各种丰富的 Starter pom 配置，在各同事的支持下，各方面的整合，都相对顺利。在接下来的文字里，我会和大家讲解贝聊在使用 Spring Boot 的一些情况。</p>
<h3 id="在-Spring-Boot-中使用-Dubbo"><a href="#在-Spring-Boot-中使用-Dubbo" class="headerlink" title="在 Spring Boot 中使用 Dubbo"></a>在 Spring Boot 中使用 Dubbo</h3><p>贝聊服务端使用了 Dubbo 框架来实现服务治理，Dubbo 目前在  Apache 孵化器进行孵化，官方也提供了 <a href="https://github.com/apache/incubator-dubbo-spring-boot-project" target="_blank" rel="external">incubator-dubbo-spring-boot-project</a>，不过官方的 0.1.0 版本在4月份才发布，在此之前，我们编写了自己的 spring-boot-starter-dubbo，并满足已有需求。</p>
<p>新项目在使用了 spring-boot-starter-dubbo 后，我们在暴露和引入 Dubbo 服务时，均使用了注解的形式，抛弃了原本的 xml  配置方式，开发的时候不用在关注是否在 dubbo.xml 中是否有引入服务，编码时相对轻松了不少。</p>
<h3 id="和-Elastic-Job-整合"><a href="#和-Elastic-Job-整合" class="headerlink" title="和 Elastic-Job 整合"></a>和 Elastic-Job 整合</h3><p>贝聊在很早的时候，就使用了 Elastic-Job 来进行分布式作业管理，且一直沿用了较低版本，没有做升级。之前已有的项目，Elastic-Job 的配置和作业都是放在一个 spring-job.xml 文件里面。在整合 Elastic-Job 和 Spring Boot 的时候，发现社区有开源的 spring-boot-starer-elastic-job，不过采用了最新版的 Elastic-Job-Lite。<br>在此背景下，我准备了两种方案：</p>
<ul>
<li>采用 <strong>@ImportResource({“classpath<em>:spring-</em>.xml”})</strong>  方式来兼容旧版本的 Elastic-Job 的任务，自己在写 demo 时运行正常；</li>
<li>升级 Elastic-Job 版本为 Elastic-Job-Lite，并安装最新版的 Elastic-Console ，参考社区的 Starter ,编写使用注解方式配置定时任务，去 xml；</li>
</ul>
<p>后面和同事讨论下，采用了后面的方案，升级  Elastic-Job 版本为 Elastic-Job-Lite，新项目使用 spring-boot-starter-elastic-job 来配置，并且使用注解来声明作业。至此，又一个 xml 文件被移除。</p>
<h3 id="和-Disconf-整合"><a href="#和-Disconf-整合" class="headerlink" title="和 Disconf 整合"></a>和 Disconf 整合</h3><p>Discof 是贝聊在早期引进的分布式配置管理工具，使用起来也很简单，虽然原作者已经停止维护，但还是有热心的网友提供了 <a href="https://github.com/xjzrc/disconf-spring-boot-starter" target="_blank" rel="external">disconf-spring-boot-starter</a> ，基于此 Starter ，也极大简化了我们在新项目中的配置成本，新入职的同事在配置 Discof 的时候，也不需要再去拷贝旧项目 Diconf 的 xml 配置。</p>
<h3 id="和-Mybatis、Druid-以及多数据源整合"><a href="#和-Mybatis、Druid-以及多数据源整合" class="headerlink" title="和 Mybatis、Druid 以及多数据源整合"></a>和 Mybatis、Druid 以及多数据源整合</h3><p>这部分整合是相对容易的，Mybatis 和 Druid 官方，均有提供自动化配置的 Starter pom，拿来来开箱即用。</p>
<p>需要特殊处理的是多数据源配置，之前系统用的公司统一的配置类，不过是 xml 配置。为了为复用代码，我们将其转为了 Java Config 的方式，并计划在未来也抽成一个自动化配置的 Starter 包。同样，我们在整合 Shiro 的时候，也是采用了Java Config的形式，并整合 JWT 作为接口访问令牌。</p>
<h3 id="和-Cat-监控整合"><a href="#和-Cat-监控整合" class="headerlink" title="和 Cat 监控整合"></a>和 Cat 监控整合</h3><p>APM 监控方面，我们公司使用了 cat，平台组的同事搭建了 cat，并且提供了对应的整合方式，其中一些配置 bean 注入的时候，还是使用 xml 的方式，后面笔者将其改为了 javaconfig 的方式，总个整合过程如下：</p>
<ul>
<li>1、引入cat 相关 jar 包；</li>
<li>2、如果是 web 项目，要注入 CatServletFilter ，实现 MVC层CAT配置；</li>
<li>3、如果是项目中用到了 dubbo ，添加 CatDubboFilter ；</li>
<li>4、在 META-INF 中添加 app.properties，声明项目名字；</li>
<li>5、在 logback-spring.xml 中添加 CatLogbackAppender 配置；</li>
</ul>
<p>上面的5个步骤中，前面3个步骤是可以合并为一个，2和3 两个步骤，可以通过将xml 配置变成Java Config 的方式，并生成一个 spring-boot-starter-cat-monitor 包，实现配置类的重用，下面也简单介绍下步骤2和3实现自动化配置的原理：</p>
<ul>
<li>注入CatServletFilter，主要是利用 <strong>@ConditionalOnWebApplication</strong> 注解，如果当前环境是web环境，则该配置类会生效，核心代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 功能：web 环境下，集成cat监控功能</div><div class="line"> */</div><div class="line">@Configuration</div><div class="line">@ConditionalOnWebApplication</div><div class="line">public class CatWebFilterConfigure &#123;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    public FilterRegistrationBean catFilter() &#123;</div><div class="line">        FilterRegistrationBean registration = new FilterRegistrationBean();</div><div class="line">        registration.setFilter(new CatServletFilter());</div><div class="line">        registration.addUrlPatterns(&quot;/*&quot;);</div><div class="line">        registration.setDispatcherTypes(DispatcherType.REQUEST,DispatcherType.FORWARD);</div><div class="line">        registration.setName(&quot;cat-filter&quot;);</div><div class="line">        return registration;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>注入CatDubboFilter，主要是利用Dubbo的 <strong>@Activate</strong> 来无条件激活配置。因为我们所有的项目，都整合了Dubbo，所以不需要根据环境来注入配置类。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 功能：dubbo cat 监控，使用Activate注解, 无条件自动激活,不需要在yml 配置中声明该filter 了</div><div class="line"> */</div><div class="line">@Activate(group = &#123;Constants.PROVIDER, Constants.CONSUMER&#125;)</div><div class="line">public class CatBootDubboConfigure extends Filter &#123;</div><div class="line">    //此处省略具体的埋点操作</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用-spring-boot-start-web-log-统一拦截请求和响应日志"><a href="#使用-spring-boot-start-web-log-统一拦截请求和响应日志" class="headerlink" title="使用 spring-boot-start-web-log 统一拦截请求和响应日志"></a>使用 spring-boot-start-web-log 统一拦截请求和响应日志</h3><p>上面说了好些 starter ，都是用了社区已有的轮子，当然，我们团部内部，也有封装一些简单的 Starter ，以实现代码复用，简化配置。</p>
<p>我们在日常接口开发的调试阶段，经常需要查看接口请求和响应日志。使用 Spring 来拦截接口请求和响应日志，有多种实现方式，可以自己定义 Filter，Intercepter，或者使用 Aspectj，如果每一个 Web 项目，都来写一套实现，或者从别的项目中拷贝一份，这肯定不是一个好的方式。基于此情况，践行 Spring Boot 约定优于配置的原则，我们自己内部封装了 spring-boot-start-web-log，并提供了一些常见的配置项。新的 Web 项目需要时，只需要引入依赖，并在 yml 配置文件中加入如下配置就好：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">web.log:</div><div class="line">    ## 拦截路径</div><div class="line">    mapping-path: &quot;/*&quot;</div><div class="line">    ## 排除路径</div><div class="line">    exclude-mapping-path: &quot;/files/*;/favicon.ico;/login;/captcha/*</div><div class="line">    ## 打印header,多个按照&apos;;&apos;分隔</div><div class="line">    print-header: &quot;Authorization&quot;</div><div class="line">    ## 是否允许打印日志，默认true,建议生成关闭</div><div class="line">    enable: true</div></pre></td></tr></table></figure>
<h3 id="在已有发布系统上部署-Spring-Boot-应用"><a href="#在已有发布系统上部署-Spring-Boot-应用" class="headerlink" title="在已有发布系统上部署 Spring Boot 应用"></a>在已有发布系统上部署 Spring Boot 应用</h3><p>刚开始在我们已有的发布系统上部署 Spring Boot 应用时，遇到了一些问题。</p>
<p>在部署应用方面，我们尝试了 war 包部署和 jar 部署两种方式。其中采用 war 包部署时，发现会和现有的 Resin 有冲突，需要移除 Resion 的部分 jar ，比较麻烦，所以我们采用 jar 包部署的方式。</p>
<p>使用 jar 包部署，我们也遇到了一些问题。我们已有的 Dubbo 应用部署，就是采用了 jar 包部署。去除一些 JWVM 参数是可配置的，最终都是使用到 <strong>java -cp  jar包路径  类名</strong>  的命令来运行应用。注意，这种方式，是需要指定jar路径和类名的，和 <strong>java -jar spring-boot-app.jar</strong>是不一样的，因此，为了避免脚本改动，我们得适配现有的发布脚本。</p>
<p>Dubbo 打成可独立运行的 jar  包，使用了 <strong>maven-shade-plugin</strong> 插件，指定的类名是 <strong>com.alibaba.dubbo.container.Main</strong> 。而在打包 Spring Boot 应用时，我们采用了 <strong>spring-boot-maven-plugin</strong>插件 。在选择<strong>java -cp</strong> 命令所需要参数类名时，我们刚开始使用了Spring Boot默认的 Application 启动类，毕竟我们开发的时候，也是直接运行该类的 main 方法来启动应用。然而实际运行的时候，发现应用根本起不来，提示找不到或无法加载主类。后面经过一番资料查找与学习，才解决了该问题。</p>
<p>解决问题的关键，在于要了解 jar 运行的原理，也就是MANIFEST.MF文件。<br>解压Spring Boot 打包后的jar文件，其中MANIFEST.MF文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Manifest-Version: 1.0</div><div class="line">Implementation-Title: demo</div><div class="line">Implementation-Version: 0.0.1-SNAPSHOT</div><div class="line">Archiver-Version: Plexus Archiver</div><div class="line">Built-By: Ming</div><div class="line">Implementation-Vendor-Id: com.beiliao.app</div><div class="line">Spring-Boot-Version: 1.5.4.RELEASE</div><div class="line">Implementation-Vendor: Pivotal Software, Inc.</div><div class="line">Main-Class: org.springframework.boot.loader.JarLauncher</div><div class="line">Start-Class: com.beiliao.app.DemoApplication</div><div class="line">Spring-Boot-Classes: BOOT-INF/classes/</div><div class="line">Spring-Boot-Lib: BOOT-INF/lib/</div><div class="line">Created-By: Apache Maven 3.3.1</div><div class="line">Build-Jdk: 1.8.0_73</div><div class="line">Implementation-URL: http://projects.spring.io/spring-boot/demo/</div></pre></td></tr></table></figure></p>
<p>注意到这里面 <strong>Main-Class: org.springframework.boot.loader.JarLauncher</strong> 才是主方法，使用<strong>java -jar spring-boot-app.jar</strong> 可以运行Spring Boot 应用，是因为  <strong>spring-boot-maven-plugin</strong> 插件在打包的时候已经生成该文件 ，<strong>java -jar </strong> 命令会读取到该文件 。因此，在启动Spring Boot 应用时，真正的启动命令应该是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">windows:</div><div class="line">java -cp .;c:\\Project\\boot-demo\\target\\demo-0.0.1-SNAPSHOT.jar  org.springframework.boot.loader.JarLauncher</div><div class="line">linux:</div><div class="line">java -cp .:/data/project/demo/*  org.springframework.boot.loader.JarLauncher</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是Spring Boot 在贝聊的一些应用情况。目前贝聊已经有几个新项目使用到 Spring Boot ，并在组内反响不错，用过的开发同事多说比之前直接用 Spring MVC 要方便不少。公司 gitlab 仓库的 starter 依赖包也有6个了，未来还会增加。 </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着 Spring Boot 生态社区的日益强大，贝聊服务端团队在开发部分新系统时，也逐步采用了 Spring Boot 框架，并且积累了一定的经验，在此和大家做个分享。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux Minit 18 折腾记</title>
    <link href="http://yoursite.com/2016/10/13/Linux-Minit-18-%E6%8A%98%E8%85%BE%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/10/13/Linux-Minit-18-折腾记/</id>
    <published>2016-10-13T08:12:59.000Z</published>
    <updated>2016-10-13T09:35:15.076Z</updated>
    
    <content type="html"><![CDATA[<p>一直记得一位老司机的话，永远不要放弃 Linux。于是乎，最近又花了些时间折腾 Linux ，在自己家的台式机上面安装了 Linux Minit 18，以下记录我在 Linux 中安装各种软件命令。</p>
<a id="more"></a>
<h2 id="安装-Jdk-8"><a href="#安装-Jdk-8" class="headerlink" title="安装 Jdk 8"></a>安装 Jdk 8</h2><p>默认的好像有问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install oracle-java8-installer</div></pre></td></tr></table></figure>
<h2 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h2><p>这里参考了官方推荐的 <a href="http://redis.io/topics/quickstart" target="_blank" rel="external">安装方式</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wget http://download.redis.io/releases/redis-stable.tar.gz</div><div class="line">tar -xvzf redis-stable.tar.gz -C /data/programe</div><div class="line">cd redis-stable</div><div class="line">make</div><div class="line">sudo cp src/redis-server /usr/local/bin/</div><div class="line">sudo cp src/redis-cli /usr/local/bin/</div></pre></td></tr></table></figure>
<h2 id="安裝-Idea"><a href="#安裝-Idea" class="headerlink" title="安裝 Idea"></a>安裝 Idea</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">破解地址</div><div class="line">http://idea.iteblog.com/key.php</div><div class="line"></div><div class="line">在桌面创建启动图标</div><div class="line"></div><div class="line">[Desktop Entry]</div><div class="line">Name=IdeaIU</div><div class="line">Comment=Rayn-IDEA-IU</div><div class="line">Exec=/home/rayn/idea/bin/idea.sh</div><div class="line">Icon=/home/rayn/idea/bin/idea.png</div><div class="line">Terminal=false</div><div class="line">Type=Application</div><div class="line">Categories=Developer;</div></pre></td></tr></table></figure>
<h2 id="安装-Sublime-text-3"><a href="#安装-Sublime-text-3" class="headerlink" title="安装 Sublime text 3"></a>安装 Sublime text 3</h2><ul>
<li><p>下载地址 <a href="http://www.sublimetext.com/3" target="_blank" rel="external">http://www.sublimetext.com/3</a></p>
</li>
<li><p>启用方法： 控制台 输入 subl</p>
</li>
<li><p>安装包管理，cttl +`</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import urllib.request,os,hashlib; h = &apos;2915d1851351e5ee549c20394736b442&apos; + &apos;8bc59f460fa1548d1514676163dafc88&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</div></pre></td></tr></table></figure>
</li>
<li><p>修复中文输入问题</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/gitgub &amp;&amp; git clone https://github.com/lyfeyaj/sublime-text-imfix.git Maybe you should firstly run the “sudo apt-get install git”</div><div class="line">cd sublime-text-imfix &amp;&amp; ./sublime-imfix</div></pre></td></tr></table></figure>
<p><a href="http://zhidao.baidu.com/link?url=7gZcSGqT2qgbV5mdysbX7OvoBkgc7l-HySrMiEEQJBeaznA1ZBCye8Hp5Tf_6FbHjUs3A6KCw7OOtpnvWBk2SgK8zIuukMb8a9NvoV4pkQq" target="_blank" rel="external">更多参考</a></p>
<h2 id="安装-Mysql"><a href="#安装-Mysql" class="headerlink" title="安装 Mysql"></a>安装 Mysql</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mysql-server mysql-client  </div><div class="line">sudo apt-get install libmysqld-dev</div></pre></td></tr></table></figure>
<h2 id="安装-Virtualbox"><a href="#安装-Virtualbox" class="headerlink" title="安装 Virtualbox"></a>安装 Virtualbox</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://download.virtualbox.org/virtualbox/5.1.6/virtualbox-5.1_5.1.6-110634~Ubuntu~xenial_amd64.deb</div></pre></td></tr></table></figure>
<h2 id="安装-Gradle"><a href="#安装-Gradle" class="headerlink" title="安装 Gradle"></a>安装 Gradle</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install gradle</div></pre></td></tr></table></figure>
<h2 id="安装-Tomcat8"><a href="#安装-Tomcat8" class="headerlink" title="安装 Tomcat8"></a>安装 Tomcat8</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget http://apache.mirrors.tds.net/tomcat/tomcat-8/v8.5.5/bin/apache-tomcat-8.5.5.tar.gz</div><div class="line"></div><div class="line">tar -zxvf redis-3.2.3.tar.gz -C /home/ming/data/program</div></pre></td></tr></table></figure>
<h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">参考</div><div class="line">http://www.kaijia.me/2013/05/ubuntu-latest-nginx-repo-collection/ </div><div class="line"></div><div class="line">http://www.jianshu.com/p/ec9f2391c83d</div></pre></td></tr></table></figure>
<h2 id="安装-MongoDB"><a href="#安装-MongoDB" class="headerlink" title="安装 MongoDB"></a>安装 MongoDB</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt install mongodb</div></pre></td></tr></table></figure>
<h2 id="安装-Chrome"><a href="#安装-Chrome" class="headerlink" title="安装 Chrome"></a>安装 Chrome</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">首先下载 Chrome 浏览器 ，我是通过 火狐设置代理后去官网下载</div><div class="line">/usr/bin/google-chrome-beta %U --proxy-server=&quot;SOCKS5://127.0.0.1:1080&quot;</div></pre></td></tr></table></figure>
<h2 id="安装-Conky-manager"><a href="#安装-Conky-manager" class="headerlink" title="安装 Conky-manager"></a>安装 Conky-manager</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install conky-manager</div></pre></td></tr></table></figure>
<h2 id="安装-ss-qt"><a href="#安装-ss-qt" class="headerlink" title="安装 ss-qt"></a>安装 ss-qt</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install shadowsocks-qt5</div></pre></td></tr></table></figure>
<h2 id="安装-shadowsocks"><a href="#安装-shadowsocks" class="headerlink" title="安装 shadowsocks"></a>安装 shadowsocks</h2><p><a href="https://aitanlu.com/ubuntu-shadowsocks-ke-hu-duan-pei-zhi.html" target="_blank" rel="external">linux-ubuntu使用shadowsocks客户端配置</a></p>
<h2 id="安装搜狗输入法"><a href="#安装搜狗输入法" class="headerlink" title="安装搜狗输入法"></a>安装搜狗输入法</h2><p>先安装 fcitx 等组件，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install fcitx fcitx-table-wubi-large fcitx-ui-classic fcitx-module-kimpanel</div></pre></td></tr></table></figure>
<p>然后下载 下载地址 <a href="http://pinyin.sogou.com/linux/" target="_blank" rel="external">http://pinyin.sogou.com/linux/</a></p>
<h2 id="安装-Wine"><a href="#安装-Wine" class="headerlink" title="安装 Wine"></a>安装 Wine</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:wine/wine-builds</div><div class="line">sudo apt-get update </div><div class="line">sudo apt-get install --install-recommends winehq-devel</div></pre></td></tr></table></figure>
<h2 id="安装-Winetricks"><a href="#安装-Winetricks" class="headerlink" title="安装 Winetricks"></a>安装 Winetricks</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install    winetricks</div></pre></td></tr></table></figure>
<h2 id="使用-Winetricks-安装语言包"><a href="#使用-Winetricks-安装语言包" class="headerlink" title="使用 Winetricks 安装语言包"></a>使用 Winetricks 安装语言包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">winetricks dotnet20 vjrun20</div></pre></td></tr></table></figure>
<h2 id="启动-QQ"><a href="#启动-QQ" class="headerlink" title="启动 QQ"></a>启动 QQ</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">WINEDEBUG=-all wine ~/.wine/drive_c/Program\ Files/Tencent/QQLite/Bin</div><div class="line">/QQ.exe</div></pre></td></tr></table></figure>
<h2 id="Leanote-笔记"><a href="#Leanote-笔记" class="headerlink" title="Leanote 笔记"></a>Leanote 笔记</h2><ul>
<li>下载地址 <a href="http://pan.baidu.com/s/1bpDl4eF" target="_blank" rel="external">http://pan.baidu.com/s/1bpDl4eF</a></li>
</ul>
<h2 id="nvm-安装"><a href="#nvm-安装" class="headerlink" title="nvm 安装"></a>nvm 安装</h2><ul>
<li>下载地址 <a href="http://www.kancloud.cn/summer/nodejs-install/71975" target="_blank" rel="external">http://www.kancloud.cn/summer/nodejs-install/71975</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直记得一位老司机的话，永远不要放弃 Linux。于是乎，最近又花了些时间折腾 Linux ，在自己家的台式机上面安装了 Linux Minit 18，以下记录我在 Linux 中安装各种软件命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git 常见应用场景及命令</title>
    <link href="http://yoursite.com/2016/10/10/Git-%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2016/10/10/Git-常见应用场景及命令/</id>
    <published>2016-10-10T10:23:22.000Z</published>
    <updated>2018-06-04T15:20:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git 在日常开发中用的非常普遍，对于一些用的比较少的命令，总是用到再查，然后又忘记，反复如此其实挺浪费时间的，因此写了这篇文章，做些笔记。</p>
<a id="more"></a>
<h2 id="在-github-上-fork-了别人的项目后，及时获取最新代码"><a href="#在-github-上-fork-了别人的项目后，及时获取最新代码" class="headerlink" title="在 github 上 fork 了别人的项目后，及时获取最新代码"></a>在 github 上 fork 了别人的项目后，及时获取最新代码</h2><p>我是这样做的，在 .git 文件夹中的 config  文件中，添加了下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[alias]</div><div class="line">    update = pull git@github.com:people_name/project_name.git master</div></pre></td></tr></table></figure></p>
<p>以后每次更新的时候就运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git update</div></pre></td></tr></table></figure></p>
<p>嗯，没错，就是利用了 alias  来偷懒输入那么长的地址。</p>
<h2 id="重新设置远程仓库链接地址或者协议"><a href="#重新设置远程仓库链接地址或者协议" class="headerlink" title="重新设置远程仓库链接地址或者协议"></a>重新设置远程仓库链接地址或者协议</h2><ul>
<li>比如我们在 git 上新建了或者 fork 了别人的项目，默认是走 http 协议，这样需要每次 push 都需要输入密码，而我实际上已经在 gihub 上传了我的公钥，我可以走 ssh 协议，不需要输入密码。</li>
<li>解决命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote set-url origin  git@github.com:QiuMing/project_name.git</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="删除已经-push-到远程仓库但需要忽略的文件"><a href="#删除已经-push-到远程仓库但需要忽略的文件" class="headerlink" title="删除已经 push 到远程仓库但需要忽略的文件"></a>删除已经 push 到远程仓库但需要忽略的文件</h2><ul>
<li>比如不小心吧 .idea 这个的文件不小心 push 到 git 上，需要删除。</li>
<li>解决命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ echo &apos;.idea&apos; &gt;&gt; .gitignore  ##添加到 .gitignore</div><div class="line"></div><div class="line">$ git rm —cached -r .idea   ##从 cache 中删除</div><div class="line"></div><div class="line">然后 add  commit  psuh</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 在日常开发中用的非常普遍，对于一些用的比较少的命令，总是用到再查，然后又忘记，反复如此其实挺浪费时间的，因此写了这篇文章，做些笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>JWT 介绍及常见问题解决方案</title>
    <link href="http://yoursite.com/2016/10/09/JWT-%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2016/10/09/JWT-介绍及常见问题解决方案/</id>
    <published>2016-10-09T03:14:05.000Z</published>
    <updated>2017-02-13T07:12:55.389Z</updated>
    
    <content type="html"><![CDATA[<p>JWT 全称Json Web Token，是一种基于 IETF 定制的开放标准 <a href="https://tools.ietf.org/html/rfc7519]https://tools.ietf.org/html/rfc7519" target="_blank" rel="external">RFC-7519</a> ，用作 <strong>身份认证</strong>与 <strong>数据传输</strong> 的 Token。因其 <strong>轻量</strong> 与 <strong>无状态</strong> 的特性，被广泛用于 Api 的设计，以及解决在微服务、分布式应用中，<strong>用户身份认证 </strong> 的问题。</p>
<p>本文先介绍 Json Web Token ，后面在探讨 JWT 常见问题以及解决方案。</p>
<a id="more"></a>
<h2 id="JWT-的组成"><a href="#JWT-的组成" class="headerlink" title="JWT 的组成"></a>JWT 的组成</h2><h3 id="头部-header"><a href="#头部-header" class="headerlink" title="头部-header"></a>头部-header</h3><p>这部分包括了两个类型：</p>
<ul>
<li>typ: token 的类型，一般都为 JWT。</li>
<li>alg: 算法的类型，主要有 HMAC-SHA256  和 RSA-SHA256。</li>
</ul>
<p><strong>tip</strong>：这里提一下两个加密算法。 HMAC-SHA-256 算法，即 HMAC 运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出，因为引入了密钥，所以 HMAC-SHA-256 不在是个哈希算法，更像一个加密算法。RSA-SHA256 算法，先使用 RSA 算法加密消息，在经过 SHA256 算法来进行哈希签名。</p>
<h3 id="载荷-Payload"><a href="#载荷-Payload" class="headerlink" title="载荷-Payload"></a>载荷-Payload</h3><p>承载了 Token 的具体内容.在 Payload 中保存了 Token 的 claim，即 token 的数据. 下面 JWT 推荐的字段，可以根据需求选择性设置：</p>
<ul>
<li><strong>iss</strong>: The issuer of the token，token 是给谁的。</li>
<li><strong>sub</strong>: The subject of the token，token 主体。</li>
<li><strong>exp</strong>: Expiration Time。 token 过期时间，Unix 时间戳格式。</li>
<li><strong>iat</strong>: Issued At。 token 创建时间， Unix 时间戳格式。</li>
<li><strong>jti</strong>: JWT ID。针对当前 token 的唯一标识。</li>
<li><strong>aud</strong>: Audience，及接收 token 受众。</li>
<li><strong>nbf</strong>: 即 Not before。如果当前时间在nbf里的时间之前，则Token不被接受。</li>
</ul>
<p>从上看出，JWT  保存了 <strong>用户常用的信息</strong> 和 <strong>Token 自身的信息</strong>，服务端每次从用户请求中获取 Token 后就可以从里面拿到用户的基本信息，而不像 session + cookie 那套机制，服务端将用户信息保存在 session 中。由此我们可以说，JWT 是 <strong>自说明，无状态的</strong>。</p>
<h3 id="签名-Signature"><a href="#签名-Signature" class="headerlink" title="签名-Signature"></a>签名-Signature</h3><p>JWT 的加密解密过程都是在服务端完成，用户登录后成功后，每次请求都带上 Token 作为身份凭证，客户端可以读取 token 的内容，但不需要编辑它。所以，为了防止这个身份凭证被人串改，需要签名。</p>
<p>签名要利用 Header 中声明的加密算法，如选用了HmacSHA256 算法，则公式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$encodedContent = base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload);</div><div class="line">$signature = hashHmacSHA256($encodedContent);</div></pre></td></tr></table></figure></p>
<p>因为有许多类库已经提供了对 JWT 的支持，所以签名和校验签名，它们都会帮我们完成。我们也可以在 <a href="http://jwt.io" target="_blank" rel="external">http://jwt.io</a> 上来验证我们的签名。</p>
<h2 id="Token-机制的-认证流程"><a href="#Token-机制的-认证流程" class="headerlink" title="Token 机制的 认证流程"></a>Token 机制的 认证流程</h2><ul>
<li><p>客户端使用用户名跟密码请求登录，登陆成功服务端发放 Token</p>
</li>
<li><p>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 或者响应头Authorization里</p>
</li>
<li><p>客户端每次向服务端请求资源的时候，在 header 中带上 Token</p>
</li>
<li><p>服务端使用拦截器校验每个请求header 中的 token，如果验证成功则返回请求的数据。</p>
</li>
</ul>
<h2 id="JWT-的安全性问题"><a href="#JWT-的安全性问题" class="headerlink" title="JWT 的安全性问题"></a>JWT 的安全性问题</h2><p>注意到 JWT 中的承载用户数据的 Payload 这部分数据只是简单的经过 base64 处理，这意味着一旦有 Token 泄露，这部分数据就会被暴露。针对这一点，在生产环境中，我们都会要求全站使用 HTTPS，现如今，这应该是企业站点的标配了，可以很大程度上减少 Token 被盗。其次，太过隐私的东西，不要放在 Payload。另外，我们可以使用 JSON Web Encryption（JWE）来对 Payload 中部分数据，乃至整个 Payload 进行对称加密，不过这回导致额外的开销。</p>
<h2 id="JWT-的优点"><a href="#JWT-的优点" class="headerlink" title="JWT 的优点"></a>JWT 的优点</h2><ul>
<li><p>JWT 是无状态的，对 resetful 接口与架构支持非常友好，这使得它更适用于 app 的开发，因为不需要再去把 cookie 那一套东西搬过来；也更加方便集群拓展，因为我们不需要再去搭建和维护一个会话集群。</p>
</li>
<li><p>天生支持跨域访问，因为 JWT 把用户的基本信息存储在 HTTP header 中，如果使用 cookie，则还需要使用一些跨域的解决方案。</p>
</li>
<li><p>天然防 CSRF 攻击。CSRF 攻击成功的原因正是黑客利用了 cookie 中存储的有效认证信息，用户在不知情的情况下，在别的网站点击了了它精心构造的链接，由此 cookie 在用户不知情的情况下被利用了。</p>
</li>
<li><p>基于现有的标准，许多语言都提供了对 JWT 支持的包，一些框架也提供了对 JWT 的整合，入手也很简单。</p>
</li>
<li><p>性能更优，因为不使用 cookie + session  作为认证的机制， 所有服务器端不需要在每次会话对 cookie 和 session  进行序列与反序列化，我们需要做的就是使用选定的算法和私钥解密令牌，获取用户信息。</p>
</li>
</ul>
<h2 id="JWT-常见问题及解决方案"><a href="#JWT-常见问题及解决方案" class="headerlink" title="JWT 常见问题及解决方案"></a>JWT 常见问题及解决方案</h2><h3 id="如何使-token-失效？"><a href="#如何使-token-失效？" class="headerlink" title="如何使 token 失效？"></a>如何使 token 失效？</h3><p>对于一些特殊的业务，如用户退出，往往需要使得现有 token 失效。在这个问题在 <a href="http://stackoverflow.com/questions/21978658/invalidating-json-web-tokens" target="_blank" rel="external">stackoverflow</a> 上有讨论，在此我总结了下，主要有两种思路：</p>
<ul>
<li>1、服务端维护所有有效的 token。</li>
<li>2、黑名单机制，服务端保存所有失效但是为超时的 token 。</li>
</ul>
<p>思路一的话可控性非常好，想要哪个 token 失效，删掉它即可。<br>思路二的话，在 stackoverflow 上获得的赞同数较多，以下我列出了在使用黑名单机制的情况时， token 需要失效的场景以及解决方案：</p>
<table>
<thead>
<tr>
<th>应用场景</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户退出登陆，但是 token 尚未过期</td>
<td>客户端移除 token，服务端使用 redis 维护一份 token 黑名单，并设置超时时间为其剩余的有效时间</td>
</tr>
<tr>
<td>用户在登陆状态下，修改了密码</td>
<td>服务端发放新 token ，旧 token 放入redis 黑名单，设置超时时间</td>
</tr>
<tr>
<td>admin 禁用了账户，不允许账户登陆</td>
<td>将用户放入黑名单</td>
</tr>
<tr>
<td>admin 修改了 token 中某些信息，比如用户角色</td>
<td>服务端发放新 token ，旧 token 放入redis 黑名单，设置超时时间。</td>
</tr>
<tr>
<td>某些特殊情况下需要禁止某个用户的登陆，比如发现 token 被黑客盗取。</td>
<td>如果是单个用户，可以暂时禁用账户，如果是多个，考虑修改加密的key，注意这会让全部 token 失效</td>
</tr>
</tbody>
</table>
<p><strong>tip1</strong>: 使用 redis 来维护 token  黑名单，这里存储在 redis 的数据实体可以自己定义，以下是我的设计:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;key&quot;: &quot;userId&quot;,</div><div class="line">    &quot;value&quot;: &#123;</div><div class="line">        &quot;invalid_type&quot;: &quot;失效类型:退出登陆、修改密码、修改角色、账号禁用&quot;,</div><div class="line">        &quot;start_time&quot;: &quot; token 的 发放时间 iat  &lt; start_time 都视为非法&quot;,</div><div class="line">        &quot;exp&quot;: &quot;redis 存储时间&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>tip2</strong>:其实有种做法是在关系型数据库里面存一些字段，然后每次校验 token 时候都去查询数据库，这种做法可以做到即时校验 token 的有效性，但是这种做法开销较大，笔者并不推荐。也有人说这种做法违背了 JWT 无状态的初衷，这里似乎涉及到对无状态的理解了，redis 也是一种数据库，这里就看设计者如何权衡了。</p>
<h3 id="如何实现-token-自动刷新"><a href="#如何实现-token-自动刷新" class="headerlink" title="如何实现 token 自动刷新?"></a>如何实现 token 自动刷新?</h3><p>如果服务端给 token 设置了一个有效期，则需要引入一套刷新机制，避免让用户重新输入密码登陆而带来的体验问题。和上面的问题一样，这个问题在  <a href="http://stackoverflow.com/questions/26739167/jwt-json-web-token-automatic-prolongation-of-expiration" target="_blank" rel="external">stackoverflow</a> 也有讨论。综合笔者查阅的资料，总结如下：</p>
<p>这个问题要具体情况具体分析：</p>
<h4 id="针对手机-App-应用"><a href="#针对手机-App-应用" class="headerlink" title="针对手机 App 应用"></a>针对手机 App 应用</h4><p>对于 App 这种需要安装在手机上的应用，因为一般情况下一个手机对应一个用户，所以很多 App 一般都只输入一次密码，对此有以下几种解决方案：</p>
<ul>
<li><p>客户端保存密码自动登陆方案。客户端获取用户密码后，将密码对称加密保存在客户端，Token 失效后，客户端在将密码取出帮用户自动登陆，从而获取新的 token。这种方案适合 app ，保存密码在本地这种方案要重点解决 密钥和用户密码的安全。</p>
</li>
<li><p>使用”永久”有效的 refresh token 方案。永久的意思是指在除去用户修改密码这种特性情况外有效。当然这个 refresh token  要和用户设备的信息挂钩，要确保只能在一个设备上使用。服务端也要对这个 refresh token 有所控制，即要做到随时可以时这个 refresh token 失效。因此，这个 refresh token 常被设计为一个包含了用户的设备信息、以及服务端存储的一个随机数。</p>
</li>
<li><p>如果 API 使用了 Https ，且服务端维护了所有的 token信息，可以考虑不需要给 Token 设置有效期，用户退出，销毁　token　即可。</p>
</li>
</ul>
<h4 id="针对-Web-应用"><a href="#针对-Web-应用" class="headerlink" title="针对 Web 应用"></a>针对 Web 应用</h4><p>对于 Web 应用，因为依托于浏览器，这里在考虑 Token 自动刷新时，更多借鉴与 session 的机制。</p>
<ul>
<li><p>定时校验刷新 Token 方案。具体思路为，将 Token 过期时间设置长一点，比如3个小时；然后每过一定时间段，比如15分钟，然后客户端通过一个全局的拦截器，在每次请求 Api 的时候，计算距离超时时间是否又缩短了一个小时，是的话就向服务端申请新的 token ，新 token 有效时间延长了一个小时。这种方案相对灵活，适合 Web App。</p>
</li>
<li><p>使用一个有较长期限的 refresh token 方案。这个 refresh token  相对于普通的 token 只是有效时间长一些。它的设计相对麻烦，因为他同要解决 refresh token 自刷新问题，服务端可控制失效问题，这里可以借鉴 Oauth 2.0 中的refresh token 机制。</p>
</li>
</ul>
<h2 id="JWT-存储-浏览器"><a href="#JWT-存储-浏览器" class="headerlink" title="JWT 存储(浏览器)"></a>JWT 存储(浏览器)</h2><p>客户端获取 Token 后， 需要临时存储，目前可以选择 local storage、session storage 和 cookie。注意如果 token 存放在 Web Storage (local storage、session storage)，需要留意 XSS 注入，因为 js 可以访问到这里。如果放入 cookie 的话，要记得加上 readOnyl，不过这又要留意 CSRF 攻击了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JWT 设计的初衷是轻量、无状态、自说明，这是它的优点，但它不是银弹，轻量表明它大小有限制，不适携带过多数据；无状态意味着它不能即使的判断 Token 的有效性，在需要引入相应的机制来弥补；自说明要求你不能直接存放敏感数据在 claim ，所以在使用 JWT 的时候，要结合现有的业务来，有时候我们可以参考 JWT 的部分优点，来设计自己的 token。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1、<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="external">RFC7519 协议</a></p>
<p>2、<a href="http://stackoverflow.com/questions/21978658/invalidating-json-web-tokens#" target="_blank" rel="external">stackoverflow 上关于如何使 Token 失效的探讨</a></p>
<p>3、<a href="http://stackoverflow.com/questions/26739167/jwt-json-web-token-automatic-prolongation-of-expiration" target="_blank" rel="external">stackoverflow 上关于 Token 到期自动延长的解决方案的探讨</a></p>
<p>4、<a href="https://auth0.com/docs/tokens/refresh-token#revoke-a-refresh-token" target="_blank" rel="external">auth0 中永久refresh 的设计</a></p>
<p>5、<a href="https://en.wikipedia.org/wiki/Stateless_protocol" target="_blank" rel="external">wiki 上关于无状态定义的描述</a></p>
<p>6、<a href="https://auth0.com/blog/angularjs-authentication-with-cookies-vs-token/" target="_blank" rel="external">cookies Vs token</a></p>
<p>7、<a href="https://auth0.com/blog/refresh-tokens-what-are-they-and-when-to-use-them/" target="_blank" rel="external">refresh token 使用</a></p>
<p>8、<a href="https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage" target="_blank" rel="external">Where to Store your JWTs – Cookies vs HTML5 Web Storage</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JWT 全称Json Web Token，是一种基于 IETF 定制的开放标准 &lt;a href=&quot;https://tools.ietf.org/html/rfc7519]https://tools.ietf.org/html/rfc7519&quot;&gt;RFC-7519&lt;/a&gt; ，用作 &lt;strong&gt;身份认证&lt;/strong&gt;与 &lt;strong&gt;数据传输&lt;/strong&gt; 的 Token。因其 &lt;strong&gt;轻量&lt;/strong&gt; 与 &lt;strong&gt;无状态&lt;/strong&gt; 的特性，被广泛用于 Api 的设计，以及解决在微服务、分布式应用中，&lt;strong&gt;用户身份认证 &lt;/strong&gt; 的问题。&lt;/p&gt;
&lt;p&gt;本文先介绍 Json Web Token ，后面在探讨 JWT 常见问题以及解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JWT" scheme="http://yoursite.com/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>使用JHispter开发微服务</title>
    <link href="http://yoursite.com/2016/07/15/%E4%BD%BF%E7%94%A8JHispter%E5%BC%80%E5%8F%91%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2016/07/15/使用JHispter开发微服务/</id>
    <published>2016-07-15T09:19:32.000Z</published>
    <updated>2016-10-09T02:57:58.403Z</updated>
    
    <content type="html"><![CDATA[<!--
# <i class="fa fa-sitemap"></i> 使用JHipster开发微服务

点此查看 [原文地址](https://jhipster.github.io/microservices-architecture/#production)
## 摘要

1. [微服务架构 vs 一体化架构](#microservices_vs_monolithic)
2. [概览](#overview)
3. [JHipster 的API 网关](#gateway)
  * [使用网关进行HTTP路由](#http_routing)
  * [安全](#security)
  * [自动生成文档](#documentation)
  * [请求速率限制](#rate_limiting)
  * [访问控制策略](#acl)
4. [JHipster 的注册中心](#registry)
  * [JHipster 注册中心概览](#registry_overview)
  * [JHipster 注册中心的安全保障](#securing_registry)
  * [在JHipster 上注册你的应用](#registry_app_configuration)
5. [创建微服务应用](#microservices)
  * [为微服务应用生成实体对象](#generating_entities)
  * [使用HazelCast做分布式缓存](#hazelcast)
  * [不带数据库的微服务应用](#no_database)
6. [使用 Docker Compose](#docker_compose)
7. [使用Jhispter Console 和ELK技术栈来监控服务](#monitoring)
8. [生产环境](#production)
  * [部署到 Docker Swarm](#docker_swarm)
  * [部署到 CloudFoundry](#cloudfoundry)
  * [部署到 Heroku](#heroku)
-->
<h2 id="微服务架构-vs-一体化架构"><a href="#微服务架构-vs-一体化架构" class="headerlink" title=" 微服务架构 vs 一体化架构"></a><a name="microservices_vs_monolithic"></a> 微服务架构 vs 一体化架构</h2><p>使用 JHipster 生成应用时，第一个问题就是让你选择你要的生成的应用(目前有4个选项)，但实际上你是在两种架构风格里面做选择：</p>
<ul>
<li>一体化架构，用来创建单独的一个应用，包含前端angular代码和后端spring boot 相关代码，项目中所有代码都在一个应用中。</li>
<li>微服务架构，进行了前后端分离，优点是它可以让你很容易的控制单个应用的规模，并处理好这些应用中一些简单细小的问题。</li>
</ul>
<p>相对来说，一体化架构是比较容易上手，官网默认推荐这个，如果是刚接触jhipstert，建议从这个入手，熟悉后，如果项目有要求，则再选择微服务架构应用。</p>
<p><em>下面部分则主要讲解下使用JHipster进行微服务架构。</em></p>
<a id="more"></a>
<h2 id="概览"><a href="#概览" class="headerlink" title=" 概览"></a><a name="overview"></a> 概览</h2><p>JHipster 微服务架构的工作方式如下：</p>
<ul>
<li><a href="#gateway">JHipster gateway</a> ，是一个可以通过生成器直接生成的(在第一个问题里面选择 microservice gateway)完整应用，包含来服务端和前端，用来处理web请求。一个微服务架构里面可以同时有几个网关，如果你遵循<a href="https://www.thoughtworks.com/cn/insights/blog/bff-soundcloud" target="_blank" rel="external"> Backends for Frontends pattern</a>这种模式，当然这不是强制性的。</li>
</ul>
<ul>
<li><p><a href="#registry">JHipster Registry</a> JHipster的注册中心，可以在github上 <a href="https://github.com/jhipster/jhipster-registry" target="_blank" rel="external">获取</a>，所有的微服务应用和网关都是从注册中心获取配置，所以它必须要先运行起来。</p>
</li>
<li><p>JHipster的微服务应用实例，可以通过生成器直接生成(在第一个问题里面选择microservice application)，它们是提供服务的具体实现。它们是无状态的。可以同时并行运行好几个相同的实例，来处理海量的请求。</p>
</li>
<li><p><a href="https://github.com/jhipster/jhipster-console" target="_blank" rel="external">JHipster Console</a>，JHipster的控制台，提供了服务监控和警报的功能，基于ELK 技术栈。</p>
</li>
</ul>
<p>在下图中，绿色的组件代表你的特定应用，蓝色组件代表的底层基础架构：</p>
<p><img src="https://jhipster.github.io/images/microservices_architecture_1.png" alt="Diagram"></p>
<h2 id="JHipster-的API-网关"><a href="#JHipster-的API-网关" class="headerlink" title=" JHipster 的API 网关"></a><a name="gateway"></a> JHipster 的API 网关</h2><p>JHipster 可以生成API gateway。 这是一个普通的JHipster 应用,在使用yo jhipster时第一个问题可以选择生成，你可以像开发一个普通应用来开发它。它在微服务架构中扮演一个入口的角色，提供了http 路由，负载均衡，api 文档、保障服务质量和安全的功能。</p>
<h3 id="使用网关进行HTTP路由"><a href="#使用网关进行HTTP路由" class="headerlink" title=" 使用网关进行HTTP路由"></a><a name="http_routing"></a> 使用网关进行HTTP路由</h3><p>Jhipster 的网关和服务应用启动之前，需要先启动 <a href="https://github.com/jhipster/jhipster-registry" target="_blank" rel="external">Jhipster register</a> 项目作为注册中心。应用在配置注册中心地址时候，只需要修改 <code>eureka.client.serviceUrl.defaultZone</code>key 对应的值 （<code>在 src/main/resources/config/application.yml</code> 文件中）。</p>
<p>网关将自动代理所有请求的服务，并沿用应用程序的名称，例如：当微服务应用<code>APP1</code>在注册中心注册后，可以通过<code>/APP1</code>网址来访问。</p>
<p>再举个例子，如果你的网关运行在<code>localhost:8080</code>，你可以通过 <a href="http://localhost:8080/app1/rest/foos" target="_blank" rel="external">http://localhost:8080/app1/rest/foos</a> 获得通过微服务APP1服务提供的的<code>foos</code>资源。</p>
<p>另外，JHipster中REST接口资源都是受保护的，在通过浏览器访问这些接口时，你需要带上正确JWT(在请求头的header上，下面安全章节的时候还会在提到)，或在<code>MicroserviceSecurityConfiguration</code>类中注释掉相关代码。</p>
<p>如果有多个相同的服务实例在同时运行，网关可以从JHipster的注册中心获取这些实例，并且：</p>
<ul>
<li><p>使用 <a href="https://github.com/Netflix/ribbon" target="_blank" rel="external">Netflix Ribbon</a> 进行负载均衡。</p>
</li>
<li><p>采用 <a href="https://github.com/Netflix/hystrix" target="_blank" rel="external">Netflix Hystrix</a> 提供的熔断机制，这样可以将挂的运行实例快速安全地移除。</p>
</li>
</ul>
<p>每个网关应用都提供了http 路由和服务实例监控的功能，在后台”管理员&gt;网关”菜单中可以看到。 </p>
<h3 id="安全"><a href="#安全" class="headerlink" title=" 安全"></a><a name="security"></a> 安全</h3><h4 id="JWT-JSON-Web-Token"><a href="#JWT-JSON-Web-Token" class="headerlink" title="JWT (JSON Web Token)"></a>JWT (JSON Web Token)</h4><p>JWT（JSON网络令牌）是现在的一个业界标准，简单易用，可以为微服务应用提供安全保障。</p>
<p>JHispter使用 <a href="https://github.com/jwtk/jjwt" target="_blank" rel="external">JJWT library</a> 库，由Stormpath提供，用来实现具体的jwt。</p>
<p>所有的toekn都由网关生成，并传送给底层微服务应用。因为它们共享一个公共的密钥，所以微服务应用能够验证该令牌，并且使用该令牌认证用户。</p>
<p>这些令牌是自给自足的：它们具有认证和授权的信息，所以微服务应用不需要查询数据库或外部系统。这是点保证了微服务的可扩展性，所以很重要。</p>
<p>为了保证服务的安全运行，一个token必须在所有应用程序之间共享：</p>
<ul>
<li><p>对于每个应用，其默认的token是独一无二的，并通过JHipster产生，被存储在 <code>.yo - rc.json</code> 文件</p>
</li>
<li><p>令牌的值可以通过修改在 <code>src /mian/resources/config/application.yml</code> 文件中的 <code>jhipster.security.authentication.jwt.secret</code> 的值来进行配置</p>
</li>
<li><p>一个好的实践是在生产环境和开发环境采用不同的token</p>
</li>
</ul>
<h4 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h4><p>此功能目前处于 <strong>BETA</strong> 阶段，因此它的文档还没有完成。</p>
<p>JHipster提供生成一个基于Srping security 的”UAA(用户账号和认证信息)”的服务 。这项服务采用Oauth2 token机制，来保证服务网关的安全。</p>
<p>在这基础上，服务网关利用Spring Security对jwt的支持来传递token给其它底层的微服务应用。</p>
<h3 id="自动生成文档"><a href="#自动生成文档" class="headerlink" title=" 自动生成文档"></a><a name="documentation"></a> 自动生成文档</h3><p>Jhipster 的网关整合了swagger API，所以我们可以很方便的使用 <code>Swagger UI</code> 和 <code>swagger-codegen</code>。在管理后台的”admin&gt; API”的菜单中，可以看到网关的API，以及所有注册了微服务的API。</p>
<p>通过下拉列表，可以查看有Swagger 生成的API文档，这些API都可以在线测试。测试的时候token会自动添加到Swagger UI 的接口中去，所以所有的请求都是在沙盒外进行。</p>
<h3 id="请求速率限制"><a href="#请求速率限制" class="headerlink" title=" 请求速率限制"></a><a name="rate_limiting"></a> 请求速率限制</h3><p>这是一个高级功能，需要建立一个Cassandra 集群（通过Docker Compose configuration 可以比较容易的搭建起来）。</p>
<p>网关提供限速的功能，所以REST请求的次数可以被限制：</p>
<ul>
<li><p>通过IP地址（匿名用户）</p>
</li>
<li><p>用户登录（登录用户）</p>
</li>
</ul>
<p>JHipster将使用Cassandra 集群存储的请求数据，并且对超出限制请求将发送HTTP 429<br>（太多请求）错误。每个用户的默认限速为每小时10万API调用。</p>
<p>这是一个重要的功能，可以保护微服务不被一些特殊的的用户请求拖垮服务器。</p>
<p>Jhipster register 作为一个管理 REST 接口资源的关卡，它对用户的安全信息拥有绝对控制权，因此它可以很容易扩展，以提供根据用户角色来进行特定速率限制。</p>
<p>为开启速率限制，需要在 <code>application-dev.yml</code> 或 <code>application-prod.yml</code> 中进行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jhipster:</div><div class="line">    gateway:</div><div class="line">        rate-limiting:</div><div class="line">            enabled: true</div></pre></td></tr></table></figure>
<p>当然 Cassandra 集群也需要搭建并配置好. 如果采用 JHipster’s Docker Compose 的配置(在 <code>src/main/docker</code> 中)，则可以正常运行。想自己手动设置群集，这里有些步骤要注意下：</p>
<ul>
<li><p>首先要有一个可用的Cassandra集群。</p>
</li>
<li><p>需要配置好JHipster特定的限速表，相关的 <code>create_keyspace.cql</code> 和 <code>create_tables.cql</code> 脚本，在 <code>src/main/resources/config/cql</code> 目录下。</p>
</li>
<li><p>该群集必须在 <code>application-*.yml</code>文件中进行配置，其对应的键为<code>spring.data.cassandra</code>（已生成了默认配置）</p>
</li>
<li><p>如果你想添加更多的规则，或修改现有规则，你需要修改RateLimitingFilter类。比如说，如果你要进行以下情况的限制：</p>
</li>
<li><p>降低HTTP调用的限制</p>
</li>
<li><p>添加每分钟或每日限制</p>
</li>
<li><p>删除了”管理员”用户的所有限制</p>
</li>
</ul>
<h3 id="访问控制策略"><a href="#访问控制策略" class="headerlink" title=" 访问控制策略"></a><a name="acl"></a> 访问控制策略</h3><p>默认情况下所有已注册的微服务都可以通过网关访问。如果你想从通过网关排除特定的API ，你可以使用网关的访问控制过滤器来对具体的访问进行控制。在 <code>application-*.yml</code> 文件中对 <code>jhipster.gateway.authorized-microservices-endpoints</code> 进行配置，默认配置为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jhipster:</div><div class="line">    gateway:</div><div class="line">        authorized-microservices-endpoints: # Access Control Policy, if left empty for a route, all endpoints will be accessible</div><div class="line">            app1: /api,/v2/api-docs # recommended dev configuration</div></pre></td></tr></table></figure>
<p>如果你只想微服务bar的 <code>/api/foo</code> 接口可以被访问，那么你只需要进行如下配置：</p>
<pre><code>jhipster:
    gateway:
        authorized-microservices-endpoints:
            bar: /api/foo
</code></pre><h2 id="JHipster-的注册中心"><a href="#JHipster-的注册中心" class="headerlink" title=" JHipster 的注册中心"></a><a name="registry"></a> JHipster 的注册中心</h2><h3 id="JHipster-注册中心概览"><a href="#JHipster-注册中心概览" class="headerlink" title=" JHipster 注册中心概览"></a><a name="registry_overview"></a> JHipster 注册中心概览</h3><p>JHipster Registry 是一个可运行的应用，由JHipster 的团队开发。和JHipster generator一样，也是开源的，遵循Apache 2-licensed，也放在github上，<a href="https://github.com/jhipster/jhipster-registry" target="_blank" rel="external">点此查看</a>。</p>
<p>可以在github上clone或者下载Registry的源码，如果使用了Jhipster generator，则建议使用使用和它相同tag的Registry，它的运行方式和其它的应用一样：</p>
<ul>
<li><p>开发环境下，直接运行 <code>./mvnw</code>，它默认采用开发环境下的配置文件，Eureka Registry 将可以通过 <a href="http://127.0.0.1:8761/" target="_blank" rel="external">http://127.0.0.1:8761/</a> 进行访问。</p>
</li>
<li><p>生产环境下，使用./mvnw -Pprod打包生成可执行WAR文件。</p>
</li>
</ul>
<p>如果想通过docker镜像来运行JHipster Registry，Docker Hub 中也有提供，在<a href="https://hub.docker.com/r/jhipster/jhipster-registry/" target="_blank" rel="external">JHipster Registry</a>，当然这个镜像是预先配置好。</p>
<ul>
<li>运行 <code>docker-compose -f src/main/docker/jhipster-registry.yml up</code> 来启动JHipster Registry. 然后 Eureka Registry 就会监听你8761 端口 , 由此便可以通过 <a href="http://127.0.0.1:8761/" target="_blank" rel="external">http://127.0.0.1:8761/</a> 来访问</li>
</ul>
<p>更多关于docker和JHipster Registry的问题，可以参见<a href="https://jhipster.github.io/docker-compose/" target="_blank" rel="external">docker Compose documentation </a></p>
<h3 id="JHipster-注册中心的安全保障"><a href="#JHipster-注册中心的安全保障" class="headerlink" title=" JHipster 注册中心的安全保障"></a><a name="securing_registry"></a> JHipster 注册中心的安全保障</h3><p>JHipster Registry 默认是受保护的，需要使用账户和密码来登陆，默认账号密码为”admin/admin”。</p>
<p>微服务应用当然也是以admin的角色在Registry上进行注册，但是是通过HTTP Basic 认证。所以如果你的微服务应用不能连接到注册中心，你会收到”401 authentication error”的错误信息，因为你配置错了某些东西。</p>
<p>为了保障JHipster Registry 的安全：</p>
<ul>
<li><p>你必须修改admin的密码。此密码可以在Spring boot 的 <code>application-*.yml</code> 文件中通过修改 <code>security.user.password</code> 对应的值来实现，或者你也可以新建一个  <code>SECURITY_USER_PASSWORD</code> 环境变量。在<a href="https://jhipster.github.io/docker-compose/" target="_blank" rel="external">Docker Compose sub-generator</a>中，用到了这个变量。</p>
</li>
<li><p>因为你的应用程序是通过HTTP连接到Registry，所以保障连接通道的安全性很重要，其中一个比较简单的方式是采用HTTPS。</p>
</li>
</ul>
<h3 id="在JHipster-上注册你的应用"><a href="#在JHipster-上注册你的应用" class="headerlink" title=" 在JHipster 上注册你的应用"></a><a name="registry_app_configuration"></a> 在JHipster 上注册你的应用</h3><p>JHipster Registry 是采用了 <a href="https://github.com/Netflix/eureka" target="_blank" rel="external">Netflix Eureka server</a> 和 <a href="http://cloud.spring.io/spring-cloud-config/spring-cloud-config.html" target="_blank" rel="external">Spring Config Server</a>。<br>当微服务应用和或者微服务网关启动的时候，它们会首先连接到JHipster Registry去获取配置信息。</p>
<p>这些配置是指spring boot 的配置，也就是 <code>application-*.yml</code>  文件。但它们存储在中央服务器上，易于管理。</p>
<p>当整个服务启动时，微服务应用或者网关会从Registry上获取服务的配置信息并且覆盖它们原来存储在本地的配置文件。</p>
<p>以下两种配置信息是可以用的：</p>
<ul>
<li><p>开发环境下的本地配置文件（使用 dev profile），使用本地的文件系统。</p>
</li>
<li><p>git 配置信息，用在生产环境下（使用 Jhipster prod profile），存储在git 服务中。使用git可以建立tag、分支，或者回滚配置信息，这是生产环境下非常实用。</p>
</li>
</ul>
<p>为了集中管理微服务的配置，你需要按照 <code>application-*.yml</code> 的格式创建配置文件，并放在Registry 的config 文件下。要求 <strong>appname</strong> 和 <strong>profile</strong> 你的微服务应用同名和profile对应。</p>
<p>举个例子，添加了一个 <code>gateway-prod.yml</code> 文件将对所有的名为gateway的应用采用生产环境下的配置文件。此外，定义在 <code>application[-dev|prod].yml</code> 配置将对所有的应用产生效果。</p>
<p>上面提到网关路由是通过Spring boot 来配置，它们其实也可以通过Spring Config Server 来管理。举个例子，你可以在  <code>v1</code> 分支上，将应用 <code>app1-v1</code> 路由到 <code>/appl</code> 的url上，而在 <code>v2</code> 分支，将 <code>app1-v2</code> 路由到 <code>/app1</code> 的url上。这是一种无缝升级微服务的好方式，以达到不需要停止服务就可以升级的效果。</p>
<h2 id="创建微服务应用"><a href="#创建微服务应用" class="headerlink" title=" 创建微服务应用"></a><a name="microservices"></a> 创建微服务应用</h2><p>微服务应用实例是可以通过 JHipster 生成的，没有前端（生成的微服务网关会有前端，用到了angularJS ），它要配合着 Jhipster Registry 才能正常运行。</p>
<h3 id="为微服务应用生成实体对象"><a href="#为微服务应用生成实体对象" class="headerlink" title=" 为微服务应用生成实体对象"></a><a name="generating_entities"></a> 为微服务应用生成实体对象</h3><p>在用 <a href="https://jhipster.github.io/creating-an-entity/" target="_blank" rel="external">entity sub-generator</a>为微服务应用中生成entity时，和在一体化架构应用中生成entity的方式有点不一样，因为微服务实现了前后端分离，微服务应用后台只需要提供接口，不需要前端代码，因此它也就不需要生成前端代码。</p>
<p>首先，在微服务的应用中生成实体，可以采用在一体化应用中生成实体对象的方法，也可以使用 <a href="https://jhipster.github.io/jhipster-uml/" target="_blank" rel="external">JHipster UML</a> 或者 <a href="https://jhipster.github.io/jdl-studio/" target="_blank" rel="external">JDL Studio</a> 来生成更加复杂的实体以及关系。当然这不会生成AngularJS代码。</p>
<p>然后，在微服务网关应用中，再次运行<a href="https://jhipster.github.io/creating-an-entity/" target="_blank" rel="external">entity sub-generator</a>，会在开始时多出一个问题，这是专门针对网关应用的：</p>
<ul>
<li><p>有两个选项：要么像在一体化架构应用中生成实体方式那样，正常生成一个新的实体（微服务网关应用本身是一个完整的 JHipster 应用，这点上它有点像是个一体化应用），要么是利用已有的 JHipster 配置信息来生成。</p>
</li>
<li><p>如果选择后者，你需要输入微服务应用的路径，然后 JHipster 会产生网关上的前端代码（相当于是在网关应用中通过页面来管理微服务应用实体）。</p>
</li>
</ul>
<h3 id="使用HazelCast做分布式缓存"><a href="#使用HazelCast做分布式缓存" class="headerlink" title=" 使用HazelCast做分布式缓存"></a><a name="hazelcast"></a> 使用HazelCast做分布式缓存</h3><p>如果你的应用采用了 SQL 的数据库，JHipster 针对微服务 给出了不同的，支持二级缓存的解决方案：</p>
<ul>
<li>JHipster 的默认微服务缓存解决方案是采用 Hazelcast</li>
<li>你也可以采用 Ehcache(一体化应用默认支持的方案) ，或者干脆不适用缓存。</li>
</ul>
<p>默认的 Hazelcast 解决方案是支持微服务的，它可以很好的支持你拓展服务：</p>
<ul>
<li><p>使用本地缓存，你是单个服务没有一个可以同步的缓存，可能导致数据不一致。</p>
</li>
<li><p>不使用任何缓存，随着服务的拓展增加，系统的负担都放到来数据库，这也不是个很好的方案。</p>
</li>
</ul>
<p>采用 Hazelcast做缓存，需要做些特别的配置：</p>
<ul>
<li>在启动时，应用程序会连接到 JHipster 注册服务中，找到和他相同的服务实例。<ul>
<li>如果使用了 <code>dev</code> profile，JHipster 将在本地主机上 <code>127.0.0.1</code> 上创建这些实例的群集 ，使用每个实例不同的端口。默认情况下， Hazelcast端口是 <code>你的应用程序的端口+ 5701</code> (所以如果你的应用程序的端口是 <code>8081</code>，Hazelcast将使用端口 <code>13782</code>)</li>
<li>如果使用了 <code>prod</code> profile，JHipster 用它找到的所有其他节点来构建一个群集，使用Hazelcast默认的端口 (<code>5701</code>)</li>
</ul>
</li>
</ul>
<h3 id="不带数据库的微服务应用"><a href="#不带数据库的微服务应用" class="headerlink" title=" 不带数据库的微服务应用"></a><a name="no_database"></a> 不带数据库的微服务应用</h3><p>只有微服务应用可以创建无数据库的程序。这是因为微服务应用可以很小，可以没有用户管理的代码。</p>
<p>一个没有数据库的微服务应用很小，可用于连接到一个遗留的后端系统。</p>
<h2 id="使用-Docker-Compose-开发和部署"><a href="#使用-Docker-Compose-开发和部署" class="headerlink" title=" 使用 Docker Compose 开发和部署"></a><a name="docker_compose"></a> 使用 Docker Compose 开发和部署</h2><p>开发微服务系统，意味着你可能需要在几个不同的 services 和 databases 上同时工作，而 Docker Compose 则是一个针对此情况，管理开发，测试和生产环境的绝佳工具。</p>
<p>为此我们有一篇专门的文档来介绍 <a href="https://jhipster.github.io/docker-compose#microservices" target="_blank" rel="external">Docker Compose documentation</a> ，我们强烈建议在开发微服务架构的系统前阅读这篇文章，熟悉这方面的知识。</p>
<h2 id="使用Jhispter-Console-和ELK技术栈来监控服务"><a href="#使用Jhispter-Console-和ELK技术栈来监控服务" class="headerlink" title="使用Jhispter Console 和ELK技术栈来监控服务"></a><a name="monitoring"></a>使用Jhispter Console 和ELK技术栈来监控服务</h2><p>当你使用 docker-Compose sub-generator 的时候，会询问你是否需要为你的应用添加监控。如果选择是，它将会在你的 <code>docker-compose.yml</code> 文件下添加 JHipster-Console。当你启动系统后，就可以有通过访问 <a href="http://localhost:5601" target="_blank" rel="external">http://localhost:5601</a> 来获取系统应的日志和各种指标。更多关于监控的东西，可以参见 <a href="http://jhipster.github.io/monitoring/" target="_blank" rel="external">monitoring documentation</a></p>
<p>对比一体化应用，网关和微服务监视器提供了一些额外的功能，可以帮助你有效地监控微服务集群。例如查看日志，它可以具体到日志对于的应用程序的名称，主机，端口和Eureka ServiceId ，这样可以让你追踪到具体的service。此外，JHipster Console带有默认的仪表板，让你在同一时间查看所有的服务。</p>
<h2 id="生产环境"><a href="#生产环境" class="headerlink" title=" 生产环境"></a><a name="production"></a> 生产环境</h2><h3 id="部署到-Docker-Swarm"><a href="#部署到-Docker-Swarm" class="headerlink" title=" 部署到 Docker Swarm"></a><a name="docker_swarm"></a> 部署到 Docker Swarm</h3><p>Docker Swarm (Docker 集群管理工具) 底层使用的API 和Docker Machine (Docker管理工具) 是一样的，所以使用Docker Swarm 发布微服务应用和在你本机上发布是一样的。更多关于Docker和Docker Swarm的文档请参考 <a href="https://jhipster.github.io/docker-compose/" target="_blank" rel="external">Docker Compose documentation </a>。</p>
<h3 id="部署到-CloudFoundry"><a href="#部署到-CloudFoundry" class="headerlink" title=" 部署到 CloudFoundry"></a><a name="cloudfoundry"></a> 部署到 CloudFoundry</h3><p>使用 <a href="https://jhipster.github.io/cloudfoundry/" target="_blank" rel="external">CloudFoundry sub-generator</a> 搭建为微服务的应用原理和之前是一样的，只是你需要部署更多的应用：</p>
<ul>
<li><p>使 sub-generator 发布你的 JHipster Registry</p>
</li>
<li><p>拿到JHipster Registry 的url,你需要在你的其它应用里面配置这个地址：</p>
<ul>
<li><p>在 <code>bootstrap-prod.yml</code> 文件中，设置 <code>spring.cloud.config.uri</code> 值为 <code>http://&lt;your_jhipster_registry_url&gt;/config/</code></p>
</li>
<li><p>在 <code>application-prod.yml</code> 文件中，设置 <code>eureka.client.serviceUrl.defaultZone</code> 值为 <code>http://&lt;your_jhipster_registry_url&gt;/eureka/</code></p>
</li>
</ul>
</li>
<li><p>发布你的网关应用和微服务应用</p>
</li>
<li><p>拓展你的应用</p>
</li>
</ul>
<p>一个重要的点是 JHipster Registry 默认是不受保护的，而微服务应用也不应该直接通过外网访被访问到，用户只有通过网关才能访问到你的服务。针对此问题有两种解决方案：</p>
<ul>
<li>通过使用特定的路由来保护你的的 Cloud Foundry。</li>
</ul>
<ul>
<li>全部应用都使用 Https，并通过使用 Spring Security 的 basic authentication 来保护你的 JHipster Registry。</li>
</ul>
<h3 id="部署到-Heroku"><a href="#部署到-Heroku" class="headerlink" title="部署到 Heroku"></a><a name="heroku"></a>部署到 Heroku</h3><p>使用 <a href="https://jhipster.github.io/cloudfoundry/" target="_blank" rel="external">Heroku sub-generator</a> 的原理和之前也是是一样的，只是你需要部署更多的应用：</p>
<p>通过下面的按钮可以在 Heroku 上一键部署 JHipster Registry：</p>
<p><a href="https://dashboard-preview.heroku.com/new?&amp;template=https%3A%2F%2Fgithub.com%2Fjhipster%2Fjhipster-registry" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/c0824806f5221ebb7d25e559568582dd39dd1170/68747470733a2f2f7777772e6865726f6b7563646e2e636f6d2f6465706c6f792f627574746f6e2e706e67" alt="Deploy to Heroku"></a></p>
<p>为了保障注册中心的安全，请参考 <a href="https://jhipster.github.io/heroku/" target="_blank" rel="external">Heroku sub-generator documentation</a> </p>
<p>在获取注册中心的地址后，你的全部应用都要在 application-prod.yml 中配置这个地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">eureka:</div><div class="line">    instance:</div><div class="line">        hostname: &lt;your_jhipster_registry_url&gt;.herokuapp.com</div><div class="line">        non-secure-port: 80</div><div class="line">        prefer-ip-address: false</div></pre></td></tr></table></figure>
<p>配置好后你就可以部署你的网关应用和微服务应用。使用 Heroku sub-generator 会询问你 JHipster Registry 的地址，这个可以让你的应用程序直接到 Spring Cloud Config server 上获取它们的配置。</p>
<p><strong>注意</strong> 以上的配置是通过http协议，但是在生产环境上，建议使用HTTPS来连接到你的JHipster Registry。因为管理员的密码是通过HTTP来进行传输的，所以极力建议通过HTTPS来加密通信通道。</p>
]]></content>
    
    <summary type="html">
    
      &lt;!--
# &lt;i class=&quot;fa fa-sitemap&quot;&gt;&lt;/i&gt; 使用JHipster开发微服务

点此查看 [原文地址](https://jhipster.github.io/microservices-architecture/#production)
## 摘要

1. [微服务架构 vs 一体化架构](#microservices_vs_monolithic)
2. [概览](#overview)
3. [JHipster 的API 网关](#gateway)
  * [使用网关进行HTTP路由](#http_routing)
  * [安全](#security)
  * [自动生成文档](#documentation)
  * [请求速率限制](#rate_limiting)
  * [访问控制策略](#acl)
4. [JHipster 的注册中心](#registry)
  * [JHipster 注册中心概览](#registry_overview)
  * [JHipster 注册中心的安全保障](#securing_registry)
  * [在JHipster 上注册你的应用](#registry_app_configuration)
5. [创建微服务应用](#microservices)
  * [为微服务应用生成实体对象](#generating_entities)
  * [使用HazelCast做分布式缓存](#hazelcast)
  * [不带数据库的微服务应用](#no_database)
6. [使用 Docker Compose](#docker_compose)
7. [使用Jhispter Console 和ELK技术栈来监控服务](#monitoring)
8. [生产环境](#production)
  * [部署到 Docker Swarm](#docker_swarm)
  * [部署到 CloudFoundry](#cloudfoundry)
  * [部署到 Heroku](#heroku)
--&gt;
&lt;h2 id=&quot;微服务架构-vs-一体化架构&quot;&gt;&lt;a href=&quot;#微服务架构-vs-一体化架构&quot; class=&quot;headerlink&quot; title=&quot; 微服务架构 vs 一体化架构&quot;&gt;&lt;/a&gt;&lt;a name=&quot;microservices_vs_monolithic&quot;&gt;&lt;/a&gt; 微服务架构 vs 一体化架构&lt;/h2&gt;&lt;p&gt;使用 JHipster 生成应用时，第一个问题就是让你选择你要的生成的应用(目前有4个选项)，但实际上你是在两种架构风格里面做选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一体化架构，用来创建单独的一个应用，包含前端angular代码和后端spring boot 相关代码，项目中所有代码都在一个应用中。&lt;/li&gt;
&lt;li&gt;微服务架构，进行了前后端分离，优点是它可以让你很容易的控制单个应用的规模，并处理好这些应用中一些简单细小的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相对来说，一体化架构是比较容易上手，官网默认推荐这个，如果是刚接触jhipstert，建议从这个入手，熟悉后，如果项目有要求，则再选择微服务架构应用。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;下面部分则主要讲解下使用JHipster进行微服务架构。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="微服务 JHipster" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1-JHipster/"/>
    
  </entry>
  
  <entry>
    <title>JHispter实践</title>
    <link href="http://yoursite.com/2016/07/07/JHispter%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2016/07/07/JHispter实践/</id>
    <published>2016-07-07T03:10:07.000Z</published>
    <updated>2016-10-09T05:51:38.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JHipster-介绍"><a href="#JHipster-介绍" class="headerlink" title="JHipster 介绍"></a>JHipster 介绍</h3><p>JHipster 是一个Java web的全栈项目，JHipster 的英文意思是 Java 潮人，注意它的前两个字母是大写。他以Spring boot做后台支撑，Angular2 做前端框架，集代码生成，提供多种技术方案选项，从对多种数据库的支持，到 docker 、Kubernetes 等最新技术，它值得每个 Javaer 都去研究的框架。</p>
<a id="more"></a>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul>
<li><p>服务端：<br>Java环境，jdk1.8(里面用到很多java8 的新特性)<br>依赖管理工具：maven 或gradle<br>数据库：mysql 或者 mongodb 、cassandra 、PostgreSQL、Oracle</p>
</li>
<li><p>前端：<br>安装Node.js ，npm 包管理器，然后npm 安装下面几个模块：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">npm install -g yo      ## Yeoman ,更新npm install -g  yo </div><div class="line">npm install -g bower    ## Bower  </div><div class="line">npm install -g gulp     ## gulp</div><div class="line">npm install -g generator-jhipster  ##JHipster 生成器 </div><div class="line">npm install -g jhipster-uml  ## JHipster uml 工具</div><div class="line">npm install -g generator-jhipster to update  ## 更新JHipster 生成器</div></pre></td></tr></table></figure>
<h3 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h3><ul>
<li>生成项目<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">yo jhipster</div><div class="line">yo jhipster:import-jdl your-jdl-file.jh</div><div class="line">yo jhipster:server</div><div class="line">yo jhipster:client</div></pre></td></tr></table></figure>
</li>
</ul>
<p>后面会有16个问题，其中第一个问题的选项：</p>
<pre><code>* monolithic     application   #单体架构应用
* microservice  application   #微服务应用
* microservice  gateway       #微服务网关
* [beat] JHipster UAA server  #(使用OAuth2 作为认证机制的微服务)
</code></pre><p>这里我们它推荐我们先选择单页应用，比较简单入手，适合创建小型 Web 站点。</p>
<ul>
<li>项目配置,后台主要是spring boot 相关配置，其中 metrics 和 logstash 都是关闭的。</li>
</ul>
<h3 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h3><ul>
<li>服务端 根据构建工具运行启动命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mvn spring-boot:run -Pprod</div><div class="line">gradle bootRun</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>前端 gulp<br>gulp 是一个前端构建打包工具。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gulp        #默认是运行gulp server ,可以开启热加载模式，用作在开发模式下。</div><div class="line">gulp build  #在target下生成被压缩过后的www 镜头资源文件，这可以用于生产环境。</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>测试框架</p>
<ul>
<li><p>gatling:Gatling: 基于Scala、Akka和Netty的开源负载测试框架</p>
</li>
<li><p>protractor:是为Angular JS应用量身打造的端到端测试框架。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;JHipster-介绍&quot;&gt;&lt;a href=&quot;#JHipster-介绍&quot; class=&quot;headerlink&quot; title=&quot;JHipster 介绍&quot;&gt;&lt;/a&gt;JHipster 介绍&lt;/h3&gt;&lt;p&gt;JHipster 是一个Java web的全栈项目，JHipster 的英文意思是 Java 潮人，注意它的前两个字母是大写。他以Spring boot做后台支撑，Angular2 做前端框架，集代码生成，提供多种技术方案选项，从对多种数据库的支持，到 docker 、Kubernetes 等最新技术，它值得每个 Javaer 都去研究的框架。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JHipster" scheme="http://yoursite.com/tags/JHipster/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 笔记</title>
    <link href="http://yoursite.com/2016/06/30/MongoDB-%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/06/30/MongoDB-笔记/</id>
    <published>2016-06-30T09:54:13.000Z</published>
    <updated>2016-10-13T09:07:48.686Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB 最近几年，以其独特的性能优势，及独特的文档型数据结构，占有了大部分 Nosql 市场，因此，熟悉掌握 MongoDB 的使用，对于开发者显得十分必要。</p>
<a id="more"></a>
<h2 id="MongoDB-的安装"><a href="#MongoDB-的安装" class="headerlink" title="MongoDB 的安装"></a>MongoDB 的安装</h2><ul>
<li><p>windows 下安装，<a href="http://www.runoob.com/mongodb/mongodb-window-install.html" target="_blank" rel="external">参见此教程</a></p>
</li>
<li><p>将其添加到系统服务，在 cmd 系统管理员模式下运行下面命令(路径按实际情况改动)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod.exe  --logpath &quot;C:\Program Files\MongoDB\data\log\mongo.log&quot; --logappend --dbpath &quot;C:\Program Files\MongoDB\data\db&quot; --port 27017 --serviceName &quot;mongodb&quot; --serviceDisplayName &quot;mongodb&quot; --install</div></pre></td></tr></table></figure>
<ul>
<li>设置开机自启动</li>
</ul>
<p>cmd 下运行services.msc 找到mongo 后设置自动启动</p>
<ul>
<li>连接远程的mongo</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongo 192.168.111.200:27017/mdoctor -u mdoctor -p password</div></pre></td></tr></table></figure>
<h2 id="MongoDB-的数据结构以及底层"><a href="#MongoDB-的数据结构以及底层" class="headerlink" title="MongoDB 的数据结构以及底层"></a>MongoDB 的数据结构以及底层</h2><p>存储格式：面向集合存储，一个collection 相当于mysql中的一个table，底层文件存储格式为BSON（一种JSON的扩展），Binary JSON </p>
<h2 id="MongoDB-的业务场景"><a href="#MongoDB-的业务场景" class="headerlink" title="MongoDB 的业务场景"></a>MongoDB 的业务场景</h2><p> mongodb的主要目标是在键/值存储方式（提供了高性能和高度伸缩性）以及传统的RDBMS系统（丰富的功能）架起一座桥梁，集两者的优势于一身。mongo适用于以下场景：</p>
<ul>
<li><p>网站数据：mongo非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。</p>
</li>
<li><p>缓存：由于性能很高，mongo也适合作为信息基础设施的缓存层。在系统重启之后，由mongo搭建的持久化缓存可以避免下层的数据源过载。</p>
</li>
<li><p>大尺寸、低价值的数据，比如评论、回复、模板数据。使用传统的关系数据库存储一些数据时可能会比较贵，在此之前，很多程序员往往会选择传统的文件进行存储。</p>
</li>
<li><p>高伸缩性的场景：mongo非常适合由数十或者数百台服务器组成的数据库。</p>
</li>
<li><p>用于对象及JSON数据的存储：mongo的BSON数据格式非常适合文档格式化的存储及查询。</p>
</li>
</ul>
<p>不适合的场景：</p>
<ul>
<li>高度事物性的系统：例如银行或会计系统。传统的关系型数据库目前还是更适用于需要大量原子性复杂事务的应用程序</li>
</ul>
<h2 id="MongoDB-常用命令"><a href="#MongoDB-常用命令" class="headerlink" title="MongoDB 常用命令"></a>MongoDB 常用命令</h2><ul>
<li><p>查看数据库：show databases;</p>
</li>
<li><p>使用数据库：use db_name;</p>
</li>
<li><p>查看有哪些表，或者是集合：show collections|show table;</p>
</li>
<li><p>查看集合，返回的是一个数组：db.getCollections();</p>
</li>
<li><p>创建集合，db.createCollection(“nsmr”，”一些可选参数,可以不填”)</p>
</li>
<li><p>在集合中插入数据 db.sites.insert({name:”itbilu.com”})</p>
</li>
<li><p>重新命名集合类 db.COLLECTION_NAME.renameCollection(“NEW_NAME”)</p>
</li>
<li><p>删除集合类 db.COLLECTION_NAME.drop();</p>
</li>
<li><p>查询当前集合的数据条数：db.yourColl.count();</p>
</li>
<li><p>查看数据空间大小:db.userInfo.dataSize();</p>
</li>
<li><p>得到当前聚集集合所在的数据库:db.userInfo.getDB();</p>
</li>
<li><p>得到当前聚集的状态，可以查看到当前collection 的size、count啥的：db.userInfo.stats();</p>
</li>
<li><p>得到聚集集合总大小：db.userInfo.totalSize();</p>
</li>
<li><p>collection重命名：db.userInfo.renameCollection(“users”);</p>
</li>
<li><p>删除当前collection：db.userInfo.drop();</p>
</li>
</ul>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li><p>查询所有记录：db.userInfo.find();<br>相当于：select * from userInfo;</p>
</li>
<li><p>查询去掉后的当前聚集集合中的某列的重复数据：db.userInfo.distinct(“name”);<br>相当于：select distict name from userInfo;</p>
</li>
<li><p>查询age = 22的记录：db.userInfo.find({“age”: 22});<br>相当于： select * from userInfo where age = 22;</p>
</li>
<li><p>查询age &gt; 22的记录<br>db.userInfo.find({age: {$gt: 22}});<br>相当于：select * from userInfo where age &gt; 22;</p>
</li>
<li><p>查询age &lt; 22的记录<br>db.userInfo.find({age: {$lt: 22}});<br>相当于：select * from userInfo where age &lt; 22;</p>
</li>
<li><p>查询age &gt;= 25的记录<br>db.userInfo.find({age: {$gte: 25}});<br>相当于：select * from userInfo where age &gt;= 25;</p>
</li>
<li><p>查询age &lt;= 25的记录<br>db.userInfo.find({age: {$lte: 25}});</p>
</li>
<li><p>查询age &gt;= 23 并且 age &lt;= 26<br>db.userInfo.find({age: {$gte: 23, $lte: 26}});</p>
</li>
<li><p>查询name中包含 mongo的数据<br>db.userInfo.find({name: /mongo/});<br>select * from userInfo where name like ‘%mongo%’;</p>
</li>
<li><p>查询name中以mongo开头的<br>db.userInfo.find({name: /^mongo/});<br>select * from userInfo where name like ‘mongo%’;</p>
</li>
<li><p>查询之正则<br>db.userInfo..find({name:{$regex:/aaa/}})</p>
</li>
<li><p>查询指定列name、age数据<br>db.userInfo.find({}, {name: 1, age: 1});<br>相当于：select name, age from userInfo;<br>当然name也可以用true或false,当用ture的情况下河name:1效果一样，如果用false就是排除name，显示name以外的列信息。</p>
</li>
<li><p>查询指定列name、age数据, age &gt; 25<br>db.userInfo.find({age: {$gt: 25}}, {name: 1, age: 1});<br>相当于：select name, age from userInfo where age &gt; 25;</p>
</li>
<li><p>按照年龄排序<br>升序：db.userInfo.find().sort({age: 1});<br>降序：db.userInfo.find().sort({age: -1});</p>
</li>
<li><p>查询name = zhangsan, age = 22的数据<br>db.userInfo.find({name: ‘zhangsan’, age: 22});<br>相当于：select * from userInfo where name = ‘zhangsan’ and age = ‘22’;</p>
</li>
<li><p>查询前5条数据<br>db.userInfo.find().limit(5);<br>相当于：select top 5 * from userInfo;</p>
</li>
<li><p>查询10条以后的数据<br>db.userInfo.find().skip(10);</p>
</li>
<li><p>查询在5-10之间的数据<br>db.userInfo.find().limit(10).skip(5);<br>可用于分页，limit是pageSize，skip是第几页*pageSize</p>
</li>
<li><p>or与 查询<br>db.userInfo.find({$or: [{age: 22}, {age: 25}]});<br>相当于：select * from userInfo where age = 22 or age = 25;</p>
</li>
</ul>
<ul>
<li><p>in 查询<br>db.userInfo.find({_id:({$in:[20368,20369]})})</p>
</li>
<li><p>查询第一条数据<br>db.userInfo.findOne();<br>相当于：select top 1 * from userInfo;<br>db.userInfo.find().limit(1);</p>
</li>
<li><p>查询某个结果集的记录条数<br>db.userInfo.find({age: {$gte: 25}}).count();<br>相当于：select count(*) from userInfo where age &gt;= 20;</p>
</li>
<li><p>按照某列进行排序<br>db.userInfo.find({sex: {$exists: true}}).count();<br>相当于：select count(sex) from userInfo;</p>
</li>
</ul>
<h3 id="索引相关"><a href="#索引相关" class="headerlink" title="索引相关"></a>索引相关</h3><p>db.userInfo.ensureIndex({name: 1});<br>db.userInfo.ensureIndex({name: 1, ts: -1});</p>
<p>2、查询当前聚集集合所有索引<br>db.userInfo.getIndexes();</p>
<p>3、查看总索引记录大小<br>db.userInfo.totalIndexSize();</p>
<p>4、读取当前集合的所有index信息<br>db.users.reIndex();</p>
<p>5、删除指定索引<br>db.users.dropIndex(“name_1”);</p>
<p>6、删除所有索引索引<br>db.users.dropIndexes();</p>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>db.users.save({name: ‘zhangsan’, age: 25, sex: true});<br>添加的数据的数据列，没有固定，根据添加的数据为准</p>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>db.users.update({age: 25}, {$set: {name: ‘changeName’}}, false, true);<br>相当于：update users set name = ‘changeName’ where age = 25;</p>
<p>db.users.update({name: ‘Lisi’}, {$inc: {age: 50}}, false, true);<br>相当于：update users set age = age + 50 where name = ‘Lisi’;</p>
<p>db.users.update({name: ‘Lisi’}, {$inc: {age: 50}, $set: {name: ‘hoho’}}, false, true);<br>相当于：update users set age = age + 50, name = ‘hoho’ where name = ‘Lisi’;</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>db.users.remove({age: 132});</p>
<h3 id="查询修改删除"><a href="#查询修改删除" class="headerlink" title="查询修改删除"></a>查询修改删除</h3><p>db.users.findAndModify({<br>    query: {age: {$gte: 25}},<br>    sort: {age: -1},<br>    update: {$set: {name: ‘a2’}, $inc: {age: 2}},<br>    remove: true<br>});</p>
<p>db.runCommand({ findandmodify : “users”,<br>    query: {age: {$gte: 25}},<br>    sort: {age: -1},<br>    update: {$set: {name: ‘a2’}, $inc: {age: 2}},<br>    remove: true<br>});<br>update 或 remove 其中一个是必须的参数; 其他参数可选。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB 最近几年，以其独特的性能优势，及独特的文档型数据结构，占有了大部分 Nosql 市场，因此，熟悉掌握 MongoDB 的使用，对于开发者显得十分必要。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://yoursite.com/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Java8 新特性概览</title>
    <link href="http://yoursite.com/2016/06/29/Java8-%E6%96%B0%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2016/06/29/Java8-新特性学习/</id>
    <published>2016-06-29T02:06:29.000Z</published>
    <updated>2016-10-09T06:23:33.304Z</updated>
    
    <content type="html"><![CDATA[<p>Java8  的新特性可以用一本书来描述，这里是笔者通过简单学习后的一些记录，主要涉及到 Java8  的默认接口方法、函数式接口、Lambda 表达式、java 8 新的日期API 和 Java8  新增加的工具类。</p>
<a id="more"></a>
<h2 id="Java8-接口默认方法"><a href="#Java8-接口默认方法" class="headerlink" title="Java8 接口默认方法"></a>Java8 接口默认方法</h2><p>引入原因：默认方法允许您添加新的功能到现有库的接口中，并能确保与采用旧版本接口编写的代码的二进制兼容性。</p>
<p>具体实例：<br>forEach 方法是 jdk 1.8 新增的接口默认方法，正是因为有了默认方法的引入，才不会因为 Iterable 接口中添加了 forEach 方法就需要修改所有 Iterable 接口的实现类，而且forEach 使用了内循环，相对之前的for循环，有以下优点：<br>1、 不一定需要顺序处理List中的元素，顺序可以不确定<br>2、可以并行处理，充分利用多核CPU的优势<br>3、 有利于JIT编译器对代码进行优化</p>
<p>除了默认方法，Java8  还在允许在接口中定义静态方法。</p>
<h2 id="Java8-函数式接口"><a href="#Java8-函数式接口" class="headerlink" title="Java8 函数式接口"></a>Java8 函数式接口</h2><p>一个接口，如果只有一个显式声明的抽象方法，那么它就是一个函数接口。一般用@FunctionalInterface标注出来（也可以不标）。举例如下：</p>
<pre><code>@FunctionalInterface
public interface Runnable { void run(); }
public interface Callable&lt;V&gt; { V call() throws Exception; }
public interface ActionListener { void actionPerformed(ActionEvent e); }
public interface Comparator&lt;T&gt; { int compare(T o1, T o2); boolean equals(Object obj); }
</code></pre><p>Java8 中新加了个java.util.function包，里面添加了Function, Supplier, Consumer, Predicate等函数式接口，这些接口经常和 Stream 结合着用:</p>
<ul>
<li>Function<k,t>  K 是输入类型，T是输出类型，其实就是一个函数的封装</k,t></li>
<li>Predicate<t> -T作为输入，返回的boolean值作为输出，常用作filter</t></li>
<li>Consumer<t> - T作为输入，执行某种动作但没有返回值</t></li>
</ul>
<h2 id="Java8-之-Lambda-表达式"><a href="#Java8-之-Lambda-表达式" class="headerlink" title="Java8  之 Lambda 表达式"></a>Java8  之 Lambda 表达式</h2><p>java是一门面向对象的语言，在Java8之前，它也是声明式编程语言，而 Java8 中 Lambda表达式的引入，使得它在写法上具有了函数式编程的特点。但它仍然是面向对象的，因为在Java8中的编写 Lambda 表达式，实质上定义了一个匿名方法，而这个方法的后面，至少有声明一个函数接口。</p>
<p>关于 Lambda 表达式，推荐书籍《精通lambda表达式：Java多核编程》</p>
<p>另外有了 Lambda 表达式，我们可以<a href="http://www.importnew.com/14841.html" target="_blank" rel="external">不要在使用循环了</a></p>
<h2 id="Lambda-和-Stream"><a href="#Lambda-和-Stream" class="headerlink" title="Lambda  和 Stream"></a>Lambda  和 Stream</h2><p>Java8  中的 Stream是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Lambda 表达式也是一种语法糖，在编写上给我提供了方便。Java8 中引入的 Strema，则紧密结合了 Lambda 表达式，充分的发挥了它的便捷性。我们可能在学习 Stream 的同时熟悉 Lambda 表达式。</p>
<p>Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样我们就可以将多个操作依次串起来。</p>
<p>关于 Stream 的学习，推荐IBM 的<a href="http://www.ibm.com/developerworks/cn/java/j-lo-Java8streamapi/" target="_blank" rel="external">Java8  中的 Streams API 详解</a>。</p>
<h2 id="日期时间API"><a href="#日期时间API" class="headerlink" title="日期时间API"></a>日期时间API</h2><p>Java8 使用了 <strong>JSR 310</strong> 规范，新增了java.time包。<br>在Java8 版之前，如果我们想格式化日期，必须使用SimpleDateFormat类，用它格式化输入的日期类。而Java8 引入了以下的新日期时间类：<br>LocalTime、LocalDate 、LocalDateTime、OffsetDate、OffsetTime、OffsetDateTime</p>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><ul>
<li>并行数组排序<br>Java8 在java.util.Arrays类中新增了并行排序功能，能够更充分地利用多线程机制。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import java.util.Arrays;</div><div class="line">public class ParallelSort &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int arr[] = &#123;1, 4, 2, 8, 5&#125;;</div><div class="line">        Arrays.parallelSort(arr);</div><div class="line">        for(int i : arr)&#123;</div><div class="line">            System.out.print(i + &quot; &quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>java.util.Optional类<br>Java8 在java.util包中新增了Optional类，Optional 类是一个可以包含或不可以包含非空值的容器对象。主要用在判断对象空指针，提供了 orElseThrow、orElse 和 orElseGet 等方法。Optional 类更像是一个容器，它保存一个类型的值或是null值。通过使用 Optional 类的 isPresent() 方法，我们可以检查指定的对象是否为空。更多方法参考 <a href="http://www.importnew.com/6675.html" target="_blank" rel="external">Java8  Optional类深度解析</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java8  的新特性可以用一本书来描述，这里是笔者通过简单学习后的一些记录，主要涉及到 Java8  的默认接口方法、函数式接口、Lambda 表达式、java 8 新的日期API 和 Java8  新增加的工具类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java8" scheme="http://yoursite.com/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>一行命令启动Web</title>
    <link href="http://yoursite.com/2016/05/21/%E4%B8%80%E8%A1%8C%E5%91%BD%E4%BB%A4%E5%90%AF%E5%8A%A8Web/"/>
    <id>http://yoursite.com/2016/05/21/一行命令启动Web/</id>
    <published>2016-05-21T02:29:41.000Z</published>
    <updated>2016-10-09T06:24:37.396Z</updated>
    
    <content type="html"><![CDATA[<p>经常会遇到要在某一个目录下启动一个 Web的情景，有很多种实现方式。</p>
<p>其中我推荐 使用 Node.js 这种方案：</p>
<a id="more"></a>
<p>使用 Node.js 安装http-server。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hs -o -p 8000</div></pre></td></tr></table></figure></p>
<p>以下，是我有用到过的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">## python</div><div class="line">python2 -m SimpleHTTPServer 8000</div><div class="line"></div><div class="line">## python3.x</div><div class="line">python -m http.server 8000</div><div class="line"></div><div class="line">## node.js</div><div class="line">npm install -g http-server</div><div class="line">http-server -p 9000</div><div class="line">hs -p 9000   ## 上面的还可以简写 为</div><div class="line">hs -help    ## 更多用法</div><div class="line"></div><div class="line">## php(&gt;5.4)</div><div class="line">php -S 127.0.0.1:8000</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常会遇到要在某一个目录下启动一个 Web的情景，有很多种实现方式。&lt;/p&gt;
&lt;p&gt;其中我推荐 使用 Node.js 这种方案：&lt;/p&gt;
    
    </summary>
    
    
      <category term="小技巧" scheme="http://yoursite.com/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Vim常用快捷键</title>
    <link href="http://yoursite.com/2016/01/27/Vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2016/01/27/Vim常用快捷键/</id>
    <published>2016-01-27T04:56:29.000Z</published>
    <updated>2017-02-13T07:12:55.389Z</updated>
    
    <content type="html"><![CDATA[<p>学习 Vim ，从它的快捷方式开始。。。<br><a id="more"></a></p>
<h1 id="一般模式下的快捷键"><a href="#一般模式下的快捷键" class="headerlink" title="一般模式下的快捷键"></a>一般模式下的快捷键</h1><hr>
<h2 id="光标定位"><a href="#光标定位" class="headerlink" title="光标定位"></a>光标定位</h2><hr>
<h3 id="上下左右记忆技巧-非方向键控制"><a href="#上下左右记忆技巧-非方向键控制" class="headerlink" title="上下左右记忆技巧(非方向键控制)"></a>上下左右记忆技巧(非方向键控制)</h3><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>ｋ</td>
<td>　上移　　　　　ｋ</td>
</tr>
<tr>
<td>ｈ</td>
<td>　左移 　　　h　　　l</td>
</tr>
<tr>
<td>ｉ</td>
<td>　右移　　　　　j</td>
</tr>
<tr>
<td>ｊ</td>
<td>　下移</td>
</tr>
</tbody>
</table>
<p><strong>tips:</strong> 先输数字n,再输入命令，表示移动n行或n个字符</p>
<hr>
<h3 id="行移动"><a href="#行移动" class="headerlink" title="行移动"></a>行移动</h3><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>GG</td>
<td>移动到最后一行</td>
</tr>
<tr>
<td>gg</td>
<td>移动到第一行</td>
</tr>
<tr>
<td>↑ 或 k 或 ctrl+p</td>
<td>向上移动一行</td>
</tr>
<tr>
<td>↓ + 或Enter 或 j 或 Ctrl+n</td>
<td>向下移动一行</td>
</tr>
<tr>
<td>nj</td>
<td>光标向下移动n行</td>
</tr>
<tr>
<td>nk</td>
<td>光标向上移动n行</td>
</tr>
<tr>
<td>nG</td>
<td>移动到第行(先输数字，观察右下角，再大写G)</td>
</tr>
<tr>
<td>H/M/L</td>
<td>当前屏幕的header/middle/last 行</td>
</tr>
<tr>
<td>0/$ 或 home/end</td>
<td>行首/行尾</td>
</tr>
<tr>
<td>*/#</td>
<td>光标跳到下/上一个光标所在单词</td>
</tr>
</tbody>
</table>
<h3 id="单词移动"><a href="#单词移动" class="headerlink" title="单词移动"></a>单词移动</h3><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>W w</td>
<td>移动到下一个单词开头</td>
</tr>
<tr>
<td>E e</td>
<td>移动到下一个单词结尾</td>
</tr>
<tr>
<td>B b</td>
<td>倒退到上一个单词开头</td>
</tr>
</tbody>
</table>
<p><strong>tips:</strong> 大写会忽略标点一同，也可以使用数字来移动多个单词</p>
<h3 id="翻页操作"><a href="#翻页操作" class="headerlink" title="翻页操作"></a>翻页操作</h3><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>翻页操作</td>
</tr>
<tr>
<td>ctrl+b/ctrl+p 或Page up/down</td>
<td>上/下一屏(back/forward)</td>
</tr>
<tr>
<td>翻半页操作</td>
</tr>
<tr>
<td>ctrl+d</td>
<td>向下翻半页(down)</td>
</tr>
<tr>
<td>ctrl+u</td>
<td>向上翻半页操作(up)</td>
</tr>
</tbody>
</table>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>``</td>
<td>光标回到上次的位置</td>
</tr>
<tr>
<td>*/#</td>
<td>光标跳到下/上一个光标所在单词</td>
</tr>
</tbody>
</table>
<p><strong>tips:</strong>   上面几个键前面加上数字n可以指定移动n行或者n个字符</p>
<hr>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>字符删除</td>
</tr>
<tr>
<td>x</td>
<td>删除光标所在字符</td>
</tr>
<tr>
<td>X</td>
<td>删除光标所在前一个字符</td>
</tr>
<tr>
<td>单词删除</td>
</tr>
<tr>
<td>dw</td>
<td>删除到下一个单词开头</td>
</tr>
<tr>
<td>de</td>
<td>删除到本单词末尾</td>
</tr>
<tr>
<td>dE</td>
<td>删除到本单词末尾包括标点在内</td>
</tr>
<tr>
<td>db</td>
<td>删除到前一个单词</td>
</tr>
<tr>
<td>dB</td>
<td>删除到前一个单词包括标点在内</td>
</tr>
<tr>
<td>删除多个字符</td>
</tr>
<tr>
<td>dd</td>
<td>删除整行</td>
</tr>
<tr>
<td>d$</td>
<td>删除光标位置到本行结尾</td>
</tr>
<tr>
<td>d0</td>
<td>删除光标位置到本行开头</td>
</tr>
<tr>
<td>删除全部</td>
</tr>
<tr>
<td>ggdG</td>
<td>从第一行删除到末尾</td>
</tr>
<tr>
<td>:%d</td>
<td>命令行模式下删除，比较强大</td>
</tr>
<tr>
<td>:n1,n2</td>
<td>删除从 n1 到 n2 行</td>
</tr>
</tbody>
</table>
<p><strong>tips:</strong> 结合移动的快捷键来记忆</p>
<hr>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>单个字符替换</td>
</tr>
<tr>
<td>R</td>
<td>连续替换</td>
</tr>
<tr>
<td>~</td>
<td>更改大小写</td>
</tr>
<tr>
<td>c</td>
<td>w</td>
<td>从光标处修改到单词结尾</td>
</tr>
<tr>
<td>cb</td>
<td>从光标处修改到单词开头</td>
</tr>
<tr>
<td>c</td>
<td>$</td>
<td>从光标修改到本行末尾</td>
</tr>
<tr>
<td>C</td>
<td>功能同上</td>
</tr>
<tr>
<td>c0</td>
<td>从光标修改到本行开头</td>
</tr>
<tr>
<td>cc</td>
<td>删除整行从头修改</td>
</tr>
<tr>
<td>S</td>
<td>功能同上</td>
</tr>
<tr>
<td>s</td>
<td>删除光标所在位置的字符，然后插入</td>
</tr>
</tbody>
</table>
<h2 id="复制黏贴"><a href="#复制黏贴" class="headerlink" title="复制黏贴"></a>复制黏贴</h2><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>黏贴</td>
</tr>
<tr>
<td>复制(y+一些移动的快捷键)</td>
</tr>
<tr>
<td>y0</td>
<td>复制到行首</td>
</tr>
<tr>
<td>y$</td>
<td>复制到行末</td>
</tr>
<tr>
<td>yy</td>
<td>复制整行</td>
</tr>
<tr>
<td>yH</td>
<td>从当前行复制到屏幕顶端</td>
</tr>
<tr>
<td>yL</td>
<td>从当前行复制到屏幕低端</td>
</tr>
<tr>
<td>ynl</td>
<td>向右复制n个字符</td>
</tr>
<tr>
<td>ynh</td>
<td>向左复制n个字符</td>
</tr>
<tr>
<td>ynw</td>
<td>向前复制n个单词</td>
</tr>
<tr>
<td>ynb</td>
<td>向后复制n个单词</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="恢复重做"><a href="#恢复重做" class="headerlink" title="恢复重做"></a>恢复重做</h2><table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>撤消上次命令</td>
</tr>
<tr>
<td>U</td>
<td>恢复整行</td>
</tr>
<tr>
<td>ctrl+r</td>
<td>重做</td>
</tr>
<tr>
<td>.</td>
<td>重复</td>
</tr>
<tr>
<td>(命令行下操作)e！</td>
<td>全文恢复</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><hr>
<h2 id="保存于退出"><a href="#保存于退出" class="headerlink" title="保存于退出"></a>保存于退出</h2><table>
<thead>
<tr>
<th>说明</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>显示行号</td>
<td>set nu</td>
</tr>
<tr>
<td>强制离开不存储</td>
<td>q!</td>
</tr>
<tr>
<td>强制保存后离开</td>
<td>wq!</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/string</td>
<td>查找string，默认向下</td>
</tr>
<tr>
<td>?string</td>
<td>同上，默认向上查找</td>
</tr>
</tbody>
</table>
<p><strong>tips:</strong> n键跳到下一个，N上一个，另外按/键后，按上下键可以找到以前查找的记录，同样的 ：也有记录</p>
<p><a href="http://www.cnblogs.com/nerxious/tag/VIM/" target="_blank" rel="external">参考</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习 Vim ，从它的快捷方式开始。。。&lt;br&gt;
    
    </summary>
    
    
      <category term="Vim" scheme="http://yoursite.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Hexo小计</title>
    <link href="http://yoursite.com/2016/01/27/Hexo%E5%B0%8F%E8%AE%A1/"/>
    <id>http://yoursite.com/2016/01/27/Hexo小计/</id>
    <published>2016-01-27T04:56:29.000Z</published>
    <updated>2017-02-13T07:12:55.389Z</updated>
    
    <content type="html"><![CDATA[<p>因为选择了技术这条路，也选择了通过 Hexo 来写博客，所以，这篇小记，用来记录笔者在使用 Hexo 的常用命令，以及遇到的一些问题。</p>
<a id="more"></a>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">hexo new &quot;postName&quot; 		#新建文章</div><div class="line">hexo new page &quot;pageName&quot;	#新建页面</div><div class="line">hexo generate		#生成静态页面至public目录</div><div class="line">hexo server		#开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</div><div class="line">hexo deploy		#将.deploy目录部署到GitHub</div><div class="line">hexo help 		#查看帮助</div><div class="line">hexo version		#查看Hexo的版本</div><div class="line">hexo deploy -g 		#生成加部署</div><div class="line">hexo server -g		#生成加预览</div></pre></td></tr></table></figure>
<h2 id="命令的简写"><a href="#命令的简写" class="headerlink" title="命令的简写"></a>命令的简写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hexo n == hexo new</div><div class="line">hexo g == hexo generate</div><div class="line">hexo s == hexo server</div><div class="line">hexo d == hexo deploy</div></pre></td></tr></table></figure>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><ul>
<li>下载主题放到 themes 文件夹中，在 _config.ym 中修改 theme 的名字</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li>ERROR Deployer not found: git 或者 ERROR Deployer not found: github</li>
<li>解决方法： npm install hexo-deployer-git –save </li>
<li>deploy 里面的 type 值为 git</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为选择了技术这条路，也选择了通过 Hexo 来写博客，所以，这篇小记，用来记录笔者在使用 Hexo 的常用命令，以及遇到的一些问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="博客 Hexo" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2-Hexo/"/>
    
  </entry>
  
</feed>
